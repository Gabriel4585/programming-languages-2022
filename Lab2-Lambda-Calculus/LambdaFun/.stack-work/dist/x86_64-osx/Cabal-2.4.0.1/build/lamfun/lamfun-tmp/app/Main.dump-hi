
==================== FINAL INTERFACE ====================
2019-11-21 22:26:26.013809 UTC

interface main:Main 8064
  interface hash: b9f3fdc5df2890cd668ec6c7041a4f2b
  ABI hash: 9f69fc41772e6b539bd0c2da1dab512d
  export-list hash: 5dd128fb350bbcd4f1c40eada8c9114b
  orphan hash: 3afd492ba1e1d1e0cdb5cc557d384f8f
  flag hash: a89434c627e301e5ad760d2c2c5bca5f
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.main
module dependencies:
package dependencies: Earley-0.13.0.1 LamFun-3.14.1 ListLike-4.6
                      ansi-terminal-0.8.2 array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bytestring-0.10.8.2 colour-2.3.4 containers-0.6.0.1 deepseq-1.4.4.0
                      directory-1.3.3.0 dlist-0.8.0.5 extra-1.6.14 filepath-1.4.2.1
                      fmlist-0.9.2 ghc-boot-th-8.6.4 ghc-prim-0.5.3 hashable-1.2.7.0
                      haskeline-0.7.5.0 integer-gmp-1.0.2.0 mtl-2.2.2 pretty-1.1.3.6
                      pretty-simple-2.2.0.1 primitive-0.6.4.0 repline-0.2.0.0 safe-0.3.17
                      silently-1.2.5 singletons-2.5.1 split-0.2.3.3 stm-2.5.0.0
                      string-conv-0.1.2 syb-0.7 template-haskell-2.14.0.0
                      terminfo-0.4.1.2 text-1.2.3.1 th-abstraction-0.2.11.0
                      th-desugar-1.9 th-expand-syns-0.4.4.0 th-lift-0.7.11
                      th-lift-instances-0.1.12 th-orphans-0.13.6 th-reify-many-0.1.8
                      time-1.8.0.2 transformers-0.5.6.2 unix-2.7.2.2
                      unordered-containers-0.2.9.0 utf8-string-1.0.1.1 vector-0.12.0.2
orphans: stm-2.5.0.0:Control.Monad.STM colour-2.3.4:Data.Colour
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian
         LamFun-3.14.1:LamInterpreter LamFun-3.14.1:LamNatInterpreter
         LamFun-3.14.1:LamRecInterpreter LamFun-3.14.1:LamMemInterpreter
         LamFun-3.14.1:LamArrayInterpreter
         ListLike-4.6:Data.ListLike.Instances
         ListLike-4.6:Data.ListLike.Text.Builder
         ListLike-4.6:Data.ListLike.Text.Text
         ListLike-4.6:Data.ListLike.Text.TextLazy
         ListLike-4.6:Data.ListLike.UTF8
         ListLike-4.6:Data.ListLike.Vector.Storable
         ListLike-4.6:Data.ListLike.Vector.Unboxed
         ListLike-4.6:Data.ListLike.Vector.Vector
         ListLike-4.6:Data.ListLike.DList ListLike-4.6:Data.ListLike.FMList
         singletons-2.5.1:Data.Singletons
         singletons-2.5.1:Data.Singletons.Prelude.Semigroup
         singletons-2.5.1:Data.Singletons.Prelude.Applicative
         singletons-2.5.1:Data.Singletons.Prelude.Const
         singletons-2.5.1:Data.Singletons.Prelude.Functor
         singletons-2.5.1:Data.Singletons.Prelude.Identity
         singletons-2.5.1:Data.Singletons.Prelude.Monoid
         singletons-2.5.1:Data.Singletons.Prelude.Semigroup.Internal
         singletons-2.5.1:Data.Singletons.TypeLits
         singletons-2.5.1:Data.Singletons.ShowSing
         singletons-2.5.1:Data.Singletons.TypeLits.Internal
         singletons-2.5.1:Data.Singletons.Prelude.Ord
         singletons-2.5.1:Data.Singletons.Prelude.Instances
         singletons-2.5.1:Data.Singletons.Decide
         th-orphans-0.13.6:Language.Haskell.TH.Instances
         th-lift-0.7.11:Language.Haskell.TH.Lift
         th-lift-instances-0.1.12:Instances.TH.Lift
         vector-0.12.0.2:Data.Vector.Unboxed
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         syb-0.7:Data.Generics.Instances
         transformers-0.5.6.2:Control.Monad.Trans.Error
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: LamFun-3.14.1:LamArrayInterpreter
                         LamFun-3.14.1:LamFunLexer LamFun-3.14.1:LamFunSyntax
                         LamFun-3.14.1:LamInterpreter LamFun-3.14.1:LamMemInterpreter
                         LamFun-3.14.1:LamNatInterpreter LamFun-3.14.1:LamRecInterpreter
                         base-4.12.0.0:Control.Applicative base-4.12.0.0:Data.Complex
                         base-4.12.0.0:Data.Functor.Compose base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.Graph
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         dlist-0.8.0.5:Data.DList ghc-boot-th-8.6.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.4:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.Color
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.Expr
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.ExprToOutput
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.Output
                         pretty-simple-2.2.0.1:Text.Pretty.Simple.Internal.OutputPrinter
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         singletons-2.5.1:Data.Singletons
                         singletons-2.5.1:Data.Singletons.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.Applicative
                         singletons-2.5.1:Data.Singletons.Prelude.Base
                         singletons-2.5.1:Data.Singletons.Prelude.Bool
                         singletons-2.5.1:Data.Singletons.Prelude.Const
                         singletons-2.5.1:Data.Singletons.Prelude.Either
                         singletons-2.5.1:Data.Singletons.Prelude.Enum
                         singletons-2.5.1:Data.Singletons.Prelude.Eq
                         singletons-2.5.1:Data.Singletons.Prelude.Foldable
                         singletons-2.5.1:Data.Singletons.Prelude.Functor
                         singletons-2.5.1:Data.Singletons.Prelude.Identity
                         singletons-2.5.1:Data.Singletons.Prelude.Instances
                         singletons-2.5.1:Data.Singletons.Prelude.IsString
                         singletons-2.5.1:Data.Singletons.Prelude.List.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.List.Internal.Disambiguation
                         singletons-2.5.1:Data.Singletons.Prelude.Maybe
                         singletons-2.5.1:Data.Singletons.Prelude.Monad.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.Monoid
                         singletons-2.5.1:Data.Singletons.Prelude.Num
                         singletons-2.5.1:Data.Singletons.Prelude.Ord
                         singletons-2.5.1:Data.Singletons.Prelude.Semigroup
                         singletons-2.5.1:Data.Singletons.Prelude.Semigroup.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.Show
                         singletons-2.5.1:Data.Singletons.Prelude.Traversable
                         singletons-2.5.1:Data.Singletons.Prelude.Tuple
                         singletons-2.5.1:Data.Singletons.Syntax
                         singletons-2.5.1:Data.Singletons.TypeLits
                         singletons-2.5.1:Data.Singletons.TypeLits.Internal
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         th-abstraction-0.2.11.0:Language.Haskell.TH.Datatype
                         th-desugar-1.9:Language.Haskell.TH.Desugar.AST
                         unordered-containers-0.2.9.0:Data.HashMap.Base
                         unordered-containers-0.2.9.0:Data.HashSet
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Storable
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
import  -/  Earley-0.13.0.1:Text.Earley 2b15b335010ee7193592897f958da502
import  -/  Earley-0.13.0.1:Text.Earley.Parser.Internal abff4937ef77425723d2361ccb27f0c0
import  -/  LamFun-3.14.1:LamArrayInterpreter 8486b56bfdb13f54f3d4f7e1f6300a0d
import  -/  LamFun-3.14.1:LamFunInterpreter 91bbda8c9f8c9fa2af6799214502d40e
import  -/  LamFun-3.14.1:LamFunLexer 909df15affead5866583bc209f6af47c
import  -/  LamFun-3.14.1:LamFunParser 3c4af5b35322123306b55c51e2e401f8
import  -/  LamFun-3.14.1:LamFunSyntax ac1b0607f12c31259d1294cbc218e4ef
import  -/  LamFun-3.14.1:LamInterpreter 2dbbae6cb3769c21aebcebecef0cf3bd
import  -/  LamFun-3.14.1:LamMemInterpreter 980345bc42a5d332f9da9cb6ab40e074
import  -/  LamFun-3.14.1:LamNatInterpreter 8128571b756af08ffc0e2df5ec09f9c7
import  -/  LamFun-3.14.1:LamRecInterpreter 5959a85dd62ad71542d76b2eca34c80c
import  -/  LamFun-3.14.1:Utils dad2562a66f1917cba62d29cd5f5c6ec
import  -/  base-4.12.0.0:Control.Monad 07eaec7fd256019b318d048d00f45b1c
import  -/  base-4.12.0.0:Control.Monad.IO.Class e96805f9d79f75be66a0d44eb83064c1
import  -/  base-4.12.0.0:Data.Either 423bee738f25e5ee983d072216009be8
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.List 17d0c71c557e42abe196f130788fd997
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Exception.Type 98b0fca1a406b013cbf2a34ff23be207
import  -/  base-4.12.0.0:GHC.IO 898d4ddbf00eb4732e5f462760aa42ae
import  -/  base-4.12.0.0:GHC.IO.Encoding 5eddf37c1e942b3a4e0865c5cf981a13
import  -/  base-4.12.0.0:GHC.IO.Exception 77722984940ee6ccf9e2f7dab10b83a4
import  -/  base-4.12.0.0:GHC.IO.Handle fe51659cf05ea3ecd36fe5e2d515d89a
import  -/  base-4.12.0.0:GHC.IO.Handle.FD 815f4d400e6239c7550e040518bdbf45
import  -/  base-4.12.0.0:GHC.IO.Handle.Text 182a34cefe4f282196178eec37b94471
import  -/  base-4.12.0.0:GHC.IO.Handle.Types 8909e00409cd23d4e66395a7e93f216d
import  -/  base-4.12.0.0:GHC.IO.IOMode 8012a3f94976206c971b9384804b372a
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:System.Exit 3c945ec7c596067c067092c41083c3d0
import  -/  base-4.12.0.0:System.IO c961e5ee6731c0683a6e879272c9e9f6
import  -/  containers-0.6.0.1:Data.Map 9f8de07f1b4905617d1dd889549a129c
import  -/  containers-0.6.0.1:Data.Map.Internal 9e74e122af4fa0c1b8d4c844eeda9c98
import  -/  extra-1.6.14:Data.List.Extra a6d1622d06cfe4a166035d97c861c2c5
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  haskeline-0.7.5.0:System.Console.Haskeline.Completion 4873b12c191ac347ac8b1139ff40584b
import  -/  haskeline-0.7.5.0:System.Console.Haskeline.MonadException ca1f12486576af3a39d00576bd8e611f
import  -/  pretty-simple-2.2.0.1:Text.Pretty.Simple c12e7f6eb0085ca91d7184de923094be
import  -/  repline-0.2.0.0:System.Console.Repline ad447114de4b80fd5757ae6b58de5b28
import  -/  silently-1.2.5:System.IO.Silently a18d5154fb85ac7b9cd4bc76e1b885df
import  -/  singletons-2.5.1:Data.Singletons 64c319757e65d960ff384963d903d8c8
import  -/  singletons-2.5.1:Data.Singletons.Internal 3383ecc7c6d9935f4cf18f0b26ad969a
import  -/  split-0.2.3.3:Data.List.Split 3518b4851dc357bd81ca9eb7a13694f0
import  -/  split-0.2.3.3:Data.List.Split.Internals b4ab8dde94aedb7514b1f8d89c369cbe
import  -/  string-conv-0.1.2:Data.String.Conv 5e3d04602479634a311e8f9d4932abfb
import  -/  transformers-0.5.6.2:Control.Monad.Trans.Class ce71df227db199c1d525fc0992381112
import  -/  transformers-0.5.6.2:Control.Monad.Trans.State.Strict acaa441e4b4c8edd4a30c00b2a2d825f
737af499549a5a5ea689f7ab364c6dc8
  $s$fApplicativeStateT ::
    GHC.Base.Applicative
      (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
                  (Main.$s$fApplicativeStateT_$s$fFunctorStateT @ s)
                  (Main.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure @ s)
                  (Main.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> @ s)
                  (Control.Monad.Trans.State.Strict.$fApplicativeStateT2
                     @ GHC.Types.IO
                     @ s
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a>_R
                   ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b>_R
                   ->_R Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                 <s>_N <GHC.Types.IO>_R <c>_N))
                  (Main.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*> @ s)
                  (\ @ a @ b ->
                   Control.Monad.Trans.State.Strict.$fApplicativeStateT2
                     @ GHC.Types.IO
                     @ s
                     GHC.Base.$fFunctorIO
                     GHC.Base.$fMonadIO
                     @ a
                     @ b
                     @ a
                     (GHC.Base.const @ a @ b))
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a>_R
                   ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b>_R
                   ->_R Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                 <s>_N <GHC.Types.IO>_R <a>_N)) -}
7ee82b0cb0e95b47d62c8ad4a6c2c386
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c*> ::
    Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U(A,U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m2 :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a)
                   (k :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b)
                   (s1 :: s)
                   (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m2
                         `cast`
                       (Control.Monad.Trans.State.Strict.N:StateT[0]
                            <s>_N <GHC.Types.IO>_R <a>_N)
                         s1)
                        `cast`
                      (GHC.Types.N:IO[0] <(a, s)>_R)
                        s2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,) a1 s' ->
                 (k `cast`
                  (Control.Monad.Trans.State.Strict.N:StateT[0]
                       <s>_N <GHC.Types.IO>_R <b>_N)
                    s')
                   `cast`
                 (GHC.Types.N:IO[0] <(b, s)>_R)
                   ipv } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b>_R
                 ->_R (<s>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(b,
                                       s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                          <s>_N <GHC.Types.IO>_R <b>_N)) -}
7a67a973d5f2db583de9aaf2018af11b
  $s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> ::
    Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO (a -> b)
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U(1*C1(U),U))))><L,1*C1(C1(U(U,1*U(U,U))))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (ds :: Control.Monad.Trans.State.Strict.StateT
                            s GHC.Types.IO (a -> b))
                   (ds1 :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a)
                   (s1 :: s)
                   (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (ds
                         `cast`
                       (Control.Monad.Trans.State.Strict.N:StateT[0]
                            <s>_N <GHC.Types.IO>_R <a -> b>_N)
                         s1)
                        `cast`
                      (GHC.Types.N:IO[0] <(a -> b, s)>_R)
                        s2 of ds2 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,) f s' ->
                 case (ds1
                         `cast`
                       (Control.Monad.Trans.State.Strict.N:StateT[0]
                            <s>_N <GHC.Types.IO>_R <a>_N)
                         s')
                        `cast`
                      (GHC.Types.N:IO[0] <(a, s)>_R)
                        ipv of ds3 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild1 { (,) x s'' -> (# ipv2, (f x, s'') #) } } } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO (a -> b)>_R
                 ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a>_R
                 ->_R (<s>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(b,
                                       s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                          <s>_N <GHC.Types.IO>_R <b>_N)) -}
6a9bef823ec9feacf71a7db88961c849
  $s$fApplicativeStateT_$s$fApplicativeStateT_$cpure ::
    a -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s
                   @ a
                   (a1 :: a)
                   (s1 :: s)
                   (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s2, (a1, s1) #))
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <a>_R
                 ->_R (<s>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(a,
                                       s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                          <s>_N <GHC.Types.IO>_R <a>_N)) -}
bc45331ff59953ce1f7a4122cdb4afc1
  $s$fApplicativeStateT_$s$fFunctorStateT ::
    GHC.Base.Functor
      (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
                  (Control.Monad.Trans.State.Strict.$fFunctorStateT_$cfmap
                     @ GHC.Types.IO
                     @ s
                     GHC.Base.$fFunctorIO)
                  (\ @ a
                     @ b
                     (x :: a)
                     (eta :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b)
                     (eta1 :: s)
                     (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case (eta
                           `cast`
                         (Control.Monad.Trans.State.Strict.N:StateT[0]
                              <s>_N <GHC.Types.IO>_R <b>_N)
                           eta1)
                          `cast`
                        (GHC.Types.N:IO[0] <(b, s)>_R)
                          s1 of ds { (#,#) ipv ipv1 ->
                   (# ipv, case ipv1 of wild { (,) a1 s' -> (x, s') } #) })
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b>_R
                   ->_R (<s>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <(a,
                                         s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                            <s>_N <GHC.Types.IO>_R <a>_N)) -}
11330ab7d1bb75ce8efd6c1f9d4930ed
  $s$fEqProgram_ ::
    GHC.Classes.Eq
      (LamFunSyntax.Program_
         v (LamFunLexer.Token Data.Text.Internal.Text))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ v :: LamFunSyntax.Version.
                  @ (LamFunSyntax.Program_
                       v (LamFunLexer.Token Data.Text.Internal.Text))
                  (LamFunSyntax.$fEqProgram__$c==
                     @ (LamFunLexer.Token Data.Text.Internal.Text)
                     @ v
                     Main.$s$fEqProgram__$s$fEqToken)
                  (LamFunSyntax.$fEqProgram__$c/=
                     @ (LamFunLexer.Token Data.Text.Internal.Text)
                     @ v
                     Main.$s$fEqProgram__$s$fEqToken) -}
f304756133a9763ef54b4727dbdc33b9
  $s$fEqProgram__$s$fEqToken ::
    GHC.Classes.Eq (LamFunLexer.Token Data.Text.Internal.Text)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (LamFunLexer.Token Data.Text.Internal.Text)
                  (\ (t1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (t2 :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case t1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case ds of wild1 { Data.Text.Internal.Text dt dt1 dt2 ->
                   case t2 of wild2 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case ds7 of wild3 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                   case GHC.Classes.eqInt
                          (GHC.Types.I# dt2)
                          (GHC.Types.I# dt5) of wild4 {
                     GHC.Types.False -> GHC.Types.False
                     GHC.Types.True
                     -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                       -> GHC.Prim.Word#
                                                       -> GHC.Prim.ByteArray#
                                                       -> GHC.Prim.Word#
                                                       -> GHC.Prim.Word#
                                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Int# #)}
                               dt
                               (GHC.Prim.int2Word# dt1)
                               dt3
                               (GHC.Prim.int2Word# dt4)
                               (GHC.Prim.int2Word# dt2)
                               GHC.Prim.realWorld# of wild5 { (#,#) ds12 ds13 ->
                        GHC.Int.eqInt32
                          (GHC.Int.I32# (GHC.Prim.narrow32Int# ds13))
                          (GHC.Int.I32# 0#) } } } } } })
                  Main.$s$fEqProgram__$s$fEqToken_$c/= -}
3bfecceee74198af9108bc347cd62051
  $s$fEqProgram__$s$fEqToken_$c/= ::
    LamFunLexer.Token Data.Text.Internal.Text
    -> LamFunLexer.Token Data.Text.Internal.Text -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(LLS)LLLL),1*U(1*U(U,U,U),A,A,A,A)><S(S(LLS)LLLL),1*U(1*U(U,U,U),A,A,A,A)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                   (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                 case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                 case ds of wild1 { Data.Text.Internal.Text dt dt1 dt2 ->
                 case y of wild2 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                 case ds7 of wild3 { Data.Text.Internal.Text dt3 dt4 dt5 ->
                 case GHC.Classes.eqInt
                        (GHC.Types.I# dt2)
                        (GHC.Types.I# dt5) of wild4 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case {__pkg_ccall text-1.2.3.1 GHC.Prim.ByteArray#
                                                     -> GHC.Prim.Word#
                                                     -> GHC.Prim.ByteArray#
                                                     -> GHC.Prim.Word#
                                                     -> GHC.Prim.Word#
                                                     -> GHC.Prim.State# GHC.Prim.RealWorld
                                                     -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                           GHC.Prim.Int# #)}
                             dt
                             (GHC.Prim.int2Word# dt1)
                             dt3
                             (GHC.Prim.int2Word# dt4)
                             (GHC.Prim.int2Word# dt2)
                             GHC.Prim.realWorld# of wild5 { (#,#) ds12 ds13 ->
                      case GHC.Int.eqInt32
                             (GHC.Int.I32# (GHC.Prim.narrow32Int# ds13))
                             (GHC.Int.I32# 0#) of wild6 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } } } } }) -}
e3bdced71106dba209e617525bd82c0d
  $s$fEq[] ::
    GHC.Classes.Eq
      [LamFunSyntax.Program_
         'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)]
                  (GHC.Classes.$fEq[]_$c==
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamNat))
                  (GHC.Classes.$fEq[]_$c/=
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamNat)) -}
2996ca35298883b5ce40f208a60a91bc
  $s$fEq[]1 ::
    GHC.Classes.Eq
      [LamFunSyntax.Program_
         'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)]
                  (GHC.Classes.$fEq[]_$c==
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamRec))
                  (GHC.Classes.$fEq[]_$c/=
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamRec)) -}
07e84ca9577fd592935dbfdd4ed1c781
  $s$fEq[]2 ::
    GHC.Classes.Eq
      [LamFunSyntax.Program_
         'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)]
                  (GHC.Classes.$fEq[]_$c==
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamMem))
                  (GHC.Classes.$fEq[]_$c/=
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamMem)) -}
33c69f808e06b2fe71fd03a3ca0283b8
  $s$fEq[]3 ::
    GHC.Classes.Eq
      [LamFunSyntax.Program_
         'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)]
                  (GHC.Classes.$fEq[]_$c==
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamCBV))
                  (GHC.Classes.$fEq[]_$c/=
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamCBV)) -}
6bd8c6a2c9b00fb33688b48ea79a2d18
  $s$fEq[]4 ::
    GHC.Classes.Eq
      [LamFunSyntax.Program_
         'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)]
                  (GHC.Classes.$fEq[]_$c==
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamCBN))
                  (GHC.Classes.$fEq[]_$c/=
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamCBN)) -}
34e79bee4258d510cad3c921bdf84ed9
  $s$fEq[]5 ::
    GHC.Classes.Eq
      [LamFunSyntax.Program_
         'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text)]
                  (GHC.Classes.$fEq[]_$c==
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamArray))
                  (GHC.Classes.$fEq[]_$c/=
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fEqProgram_ @ 'LamFunSyntax.LamArray)) -}
0429d1e584363d156b9d881bb8fdfb02
  $s$fMonadExceptionStateT_$s$fMonadIOStateT ::
    Control.Monad.IO.Class.MonadIO
      (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
                  (Main.$s$fMonadExceptionStateT_$s$fMonadStateT @ s)
                  (\ @ a
                     (x :: GHC.Types.IO a)
                     (s1 :: s)
                     (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   case x `cast` (GHC.Types.N:IO[0] <a>_R)
                          s2 of ds1 { (#,#) ipv ipv1 ->
                   (# ipv, (ipv1, s1) #) })
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Types.IO a>_R
                   ->_R (<s>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <(a,
                                         s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                            <s>_N <GHC.Types.IO>_R <a>_N)) -}
b71ca51489d4a7a407e7ae7b2afe2905
  $s$fMonadExceptionStateT_$s$fMonadStateT ::
    GHC.Base.Monad
      (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ s.
                  @ (Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO)
                  (Main.$s$fApplicativeStateT @ s)
                  (Main.$s$fMonadExceptionStateT_$s$fMonadStateT_$c>>= @ s)
                  (Main.$s$fMonadExceptionStateT_$s$fMonadStateT_$c>> @ s)
                  (\ @ a
                     (eta :: a)
                     (eta1 :: s)
                     (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                   (# s1, (eta, eta1) #))
                    `cast`
                  (forall (a :: <*>_N).
                   <a>_R
                   ->_R (<s>_R
                         ->_R Sym (GHC.Types.N:IO[0]
                                       <(a,
                                         s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                            <s>_N <GHC.Types.IO>_R <a>_N))
                  (Main.$s$fMonadExceptionStateT_$s$fMonadStateT_$cfail @ s) -}
025ce9e8a9d6d32ab1c55301b0f858d8
  $s$fMonadExceptionStateT_$s$fMonadStateT_$c>> ::
    Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U(A,U))))><L,1*C1(C1(U(U,U)))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m2 :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a)
                   (k :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b)
                   (s1 :: s)
                   (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m2
                         `cast`
                       (Control.Monad.Trans.State.Strict.N:StateT[0]
                            <s>_N <GHC.Types.IO>_R <a>_N)
                         s1)
                        `cast`
                      (GHC.Types.N:IO[0] <(a, s)>_R)
                        s2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,) a1 s' ->
                 (k `cast`
                  (Control.Monad.Trans.State.Strict.N:StateT[0]
                       <s>_N <GHC.Types.IO>_R <b>_N)
                    s')
                   `cast`
                 (GHC.Types.N:IO[0] <(b, s)>_R)
                   ipv } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a>_R
                 ->_R <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b>_R
                 ->_R (<s>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(b,
                                       s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                          <s>_N <GHC.Types.IO>_R <b>_N)) -}
7bd2d2483113e0ed43944fddb662d197
  $s$fMonadExceptionStateT_$s$fMonadStateT_$c>>= ::
    Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a
    -> (a -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b)
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <C(C(S(SS))),1*C1(C1(U(U,1*U(U,U))))><L,1*C1(C1(C1(U(U,U))))><L,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ s
                   @ a
                   @ b
                   (m2 :: Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a)
                   (k :: a
                         -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b)
                   (s1 :: s)
                   (s2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case (m2
                         `cast`
                       (Control.Monad.Trans.State.Strict.N:StateT[0]
                            <s>_N <GHC.Types.IO>_R <a>_N)
                         s1)
                        `cast`
                      (GHC.Types.N:IO[0] <(a, s)>_R)
                        s2 of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { (,) a1 s' ->
                 ((k a1)
                    `cast`
                  (Control.Monad.Trans.State.Strict.N:StateT[0]
                       <s>_N <GHC.Types.IO>_R <b>_N)
                    s')
                   `cast`
                 (GHC.Types.N:IO[0] <(b, s)>_R)
                   ipv } })
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a>_R
                 ->_R <a
                       -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO b>_R
                 ->_R (<s>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <(b,
                                       s)>_R)) ; Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                                                          <s>_N <GHC.Types.IO>_R <b>_N)) -}
25c14467ae707f80099b6cff211563cc
  $s$fMonadExceptionStateT_$s$fMonadStateT_$cfail ::
    GHC.Base.String
    -> Control.Monad.Trans.State.Strict.StateT s GHC.Types.IO a
  {- Arity: 1, Strictness: <L,U>, Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ s @ a (str :: GHC.Base.String) (ds :: s) ->
                 GHC.Magic.noinline
                   @ (forall a1. [GHC.Types.Char] -> GHC.Types.IO a1)
                   GHC.IO.failIO1
                     `cast`
                   (forall (a1 :: <*>_N).
                    <GHC.Base.String>_R ->_R Sym (GHC.Types.N:IO[0] <a1>_R))
                   @ (a, s)
                   str)
                  `cast`
                (forall (s :: <*>_N) (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Strict.N:StateT[0]
                               <s>_N <GHC.Types.IO>_R <a>_N)) -}
8b7583af9c5ea2df53348ade8361f4c1
  $s$fOrdProgram_ ::
    GHC.Classes.Ord
      (LamFunSyntax.Program_
         v (LamFunLexer.Token Data.Text.Internal.Text))
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ v :: LamFunSyntax.Version.
                  @ (LamFunSyntax.Program_
                       v (LamFunLexer.Token Data.Text.Internal.Text))
                  (Main.$s$fEqProgram_ @ v)
                  (LamFunSyntax.$fOrdProgram__$ccompare
                     @ (LamFunLexer.Token Data.Text.Internal.Text)
                     @ v
                     Main.$s$fOrdProgram__$s$fOrdToken)
                  (LamFunSyntax.$fOrdProgram__$c<
                     @ (LamFunLexer.Token Data.Text.Internal.Text)
                     @ v
                     Main.$s$fOrdProgram__$s$fOrdToken)
                  (\ (a1 :: LamFunSyntax.Program_
                              v (LamFunLexer.Token Data.Text.Internal.Text))
                     (b :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text)) ->
                   case LamFunSyntax.$fOrdProgram__$c<
                          @ (LamFunLexer.Token Data.Text.Internal.Text)
                          @ v
                          Main.$s$fOrdProgram__$s$fOrdToken
                          b
                          a1 of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (a1 :: LamFunSyntax.Program_
                              v (LamFunLexer.Token Data.Text.Internal.Text))
                     (b :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text)) ->
                   LamFunSyntax.$fOrdProgram__$c<
                     @ (LamFunLexer.Token Data.Text.Internal.Text)
                     @ v
                     Main.$s$fOrdProgram__$s$fOrdToken
                     b
                     a1)
                  (\ (a1 :: LamFunSyntax.Program_
                              v (LamFunLexer.Token Data.Text.Internal.Text))
                     (b :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text)) ->
                   case LamFunSyntax.$fOrdProgram__$c<
                          @ (LamFunLexer.Token Data.Text.Internal.Text)
                          @ v
                          Main.$s$fOrdProgram__$s$fOrdToken
                          a1
                          b of wild {
                     GHC.Types.False -> GHC.Types.True
                     GHC.Types.True -> GHC.Types.False })
                  (\ (x :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text))
                     (y :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text)) ->
                   case LamFunSyntax.$fOrdProgram__$c<
                          @ (LamFunLexer.Token Data.Text.Internal.Text)
                          @ v
                          Main.$s$fOrdProgram__$s$fOrdToken
                          y
                          x of wild {
                     GHC.Types.False -> y GHC.Types.True -> x })
                  (\ (x :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text))
                     (y :: LamFunSyntax.Program_
                             v (LamFunLexer.Token Data.Text.Internal.Text)) ->
                   case LamFunSyntax.$fOrdProgram__$c<
                          @ (LamFunLexer.Token Data.Text.Internal.Text)
                          @ v
                          Main.$s$fOrdProgram__$s$fOrdToken
                          y
                          x of wild {
                     GHC.Types.False -> x GHC.Types.True -> y }) -}
a5805879c87c815d582fae5a5720c69e
  $s$fOrdProgram__$s$fOrdToken ::
    GHC.Classes.Ord (LamFunLexer.Token Data.Text.Internal.Text)
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ (LamFunLexer.Token Data.Text.Internal.Text)
                  Main.$s$fEqProgram__$s$fEqToken
                  (\ (t1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (t2 :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case t1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case t2 of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   Data.Text.$fOrdText_$ccompare ds ds7 } })
                  (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True } } })
                  (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False } } })
                  (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True } } })
                  (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False } } })
                  (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                     DEFAULT -> wild1 GHC.Types.GT -> wild } } })
                  (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                     (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                   case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                   case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                   case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                     DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
1509910a24f19e2ce634509a84a835c1
  $s$fOrdToken_$ccompare ::
    LamFunLexer.Token Data.Text.Internal.Text
    -> LamFunLexer.Token Data.Text.Internal.Text -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SSS)LLLL),1*U(1*U(U,U,U),A,A,A,A)><S(S(SSS)LLLL),1*U(1*U(U,U,U),A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (t1 :: LamFunLexer.Token Data.Text.Internal.Text)
                   (t2 :: LamFunLexer.Token Data.Text.Internal.Text) ->
                 case t1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                 case t2 of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                 Data.Text.$fOrdText_$ccompare ds ds7 } }) -}
0c6cb880df06a1a065b821fa09d7eb70
  $s$fOrdToken_$cmax ::
    LamFunLexer.Token Data.Text.Internal.Text
    -> LamFunLexer.Token Data.Text.Internal.Text
    -> LamFunLexer.Token Data.Text.Internal.Text
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SSS)LLLL),1*U(U(U,U,U),U,U,U,U)><S(S(SSS)LLLL),1*U(U(U,U,U),U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                   (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                 case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                 case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                 case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                   DEFAULT -> wild1 GHC.Types.GT -> wild } } }) -}
c0f5ae75bba8176d2cd0845a3202c447
  $s$fOrdToken_$cmin ::
    LamFunLexer.Token Data.Text.Internal.Text
    -> LamFunLexer.Token Data.Text.Internal.Text
    -> LamFunLexer.Token Data.Text.Internal.Text
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SSS)LLLL),1*U(U(U,U,U),U,U,U,U)><S(S(SSS)LLLL),1*U(U(U,U,U),U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: LamFunLexer.Token Data.Text.Internal.Text)
                   (y :: LamFunLexer.Token Data.Text.Internal.Text) ->
                 case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                 case y of wild1 { LamFunLexer.Token ds7 ds8 ds9 ds10 ds11 ->
                 case Data.Text.$fOrdText_$ccompare ds ds7 of wild2 {
                   DEFAULT -> wild GHC.Types.GT -> wild1 } } }) -}
ace565dcbff78c76801fe3832e71baab
  $s$fOrd[] ::
    GHC.Classes.Ord
      [LamFunSyntax.Program_
         'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)]
                  Main.$s$fEq[]
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat))
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat)
                          x
                          y of wild {
                     DEFAULT -> y GHC.Types.GT -> x })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamNat
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamNat)
                          x
                          y of wild {
                     DEFAULT -> x GHC.Types.GT -> y }) -}
4f88d54ea4860f51a217fe9c50c12847
  $s$fOrd[]1 ::
    GHC.Classes.Ord
      [LamFunSyntax.Program_
         'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)]
                  Main.$s$fEq[]1
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec))
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec)
                          x
                          y of wild {
                     DEFAULT -> y GHC.Types.GT -> x })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamRec
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamRec)
                          x
                          y of wild {
                     DEFAULT -> x GHC.Types.GT -> y }) -}
8aea5339f918fc6057dc17161f29320d
  $s$fOrd[]2 ::
    GHC.Classes.Ord
      [LamFunSyntax.Program_
         'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)]
                  Main.$s$fEq[]2
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem))
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem)
                          x
                          y of wild {
                     DEFAULT -> y GHC.Types.GT -> x })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamMem
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamMem)
                          x
                          y of wild {
                     DEFAULT -> x GHC.Types.GT -> y }) -}
ffe3e2187eebc9e49341174e803a8249
  $s$fOrd[]3 ::
    GHC.Classes.Ord
      [LamFunSyntax.Program_
         'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)]
                  Main.$s$fEq[]3
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV))
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV)
                          x
                          y of wild {
                     DEFAULT -> y GHC.Types.GT -> x })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBV
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBV)
                          x
                          y of wild {
                     DEFAULT -> x GHC.Types.GT -> y }) -}
466430f6dc37e4d69d912699722e3df2
  $s$fOrd[]4 ::
    GHC.Classes.Ord
      [LamFunSyntax.Program_
         'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)]
                  Main.$s$fEq[]4
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN))
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN)
                          x
                          y of wild {
                     DEFAULT -> y GHC.Types.GT -> x })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamCBN
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamCBN)
                          x
                          y of wild {
                     DEFAULT -> x GHC.Types.GT -> y }) -}
690103dc7ddfd7bb49ab6d04da4881c2
  $s$fOrd[]5 ::
    GHC.Classes.Ord
      [LamFunSyntax.Program_
         'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text)]
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ [LamFunSyntax.Program_
                       'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text)]
                  Main.$s$fEq[]5
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                     (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray))
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray)
                          x
                          y of wild {
                     DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray)
                          x
                          y of wild {
                     DEFAULT -> y GHC.Types.GT -> x })
                  (\ (x :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)])
                     (y :: [LamFunSyntax.Program_
                              'LamFunSyntax.LamArray
                              (LamFunLexer.Token Data.Text.Internal.Text)]) ->
                   case GHC.Classes.$fOrd[]_$ccompare
                          @ (LamFunSyntax.Program_
                               'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                          (Main.$s$fOrdProgram_ @ 'LamFunSyntax.LamArray)
                          x
                          y of wild {
                     DEFAULT -> x GHC.Types.GT -> y }) -}
a02af09304dd4560c26b984d38848679
  $scompleteFilename ::
    System.Console.Haskeline.Completion.CompletionFunc
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamNat,
           Data.Map.Internal.Map
             Environment.Ident
             (LamFunSyntax.Defn_ 'LamFunSyntax.LamNat Environment.Ident)))
         GHC.Types.IO)
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 System.Console.Haskeline.Completion.$wcompleteFilename
                   @ (Control.Monad.Trans.State.Strict.StateT
                        (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamNat,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamNat Environment.Ident)))
                        GHC.Types.IO)
                   (Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT
                      @ (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamNat,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamNat Environment.Ident))))
                   ww1
                   ww2 }) -}
8db4b08e295c0105a23b26aac7baf65b
  $scompleteFilename1 ::
    System.Console.Haskeline.Completion.CompletionFunc
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamRec,
           Data.Map.Internal.Map
             Environment.Ident
             (LamFunSyntax.Defn_ 'LamFunSyntax.LamRec Environment.Ident)))
         GHC.Types.IO)
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 System.Console.Haskeline.Completion.$wcompleteFilename
                   @ (Control.Monad.Trans.State.Strict.StateT
                        (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamRec,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamRec Environment.Ident)))
                        GHC.Types.IO)
                   (Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT
                      @ (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamRec,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamRec Environment.Ident))))
                   ww1
                   ww2 }) -}
8f65fd67c5b0a1fa1f5bd9f48ebe9908
  $scompleteFilename2 ::
    System.Console.Haskeline.Completion.CompletionFunc
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamMem,
           Data.Map.Internal.Map
             Environment.Ident
             (LamFunSyntax.Defn_ 'LamFunSyntax.LamMem Environment.Ident)))
         GHC.Types.IO)
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 System.Console.Haskeline.Completion.$wcompleteFilename
                   @ (Control.Monad.Trans.State.Strict.StateT
                        (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamMem,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamMem Environment.Ident)))
                        GHC.Types.IO)
                   (Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT
                      @ (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamMem,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamMem Environment.Ident))))
                   ww1
                   ww2 }) -}
169db81a0ebd5e8e1aa6e390b0816c9f
  $scompleteFilename3 ::
    System.Console.Haskeline.Completion.CompletionFunc
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamCBV,
           Data.Map.Internal.Map
             Environment.Ident
             (LamFunSyntax.Defn_ 'LamFunSyntax.LamCBV Environment.Ident)))
         GHC.Types.IO)
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 System.Console.Haskeline.Completion.$wcompleteFilename
                   @ (Control.Monad.Trans.State.Strict.StateT
                        (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamCBV,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamCBV Environment.Ident)))
                        GHC.Types.IO)
                   (Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT
                      @ (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamCBV,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamCBV Environment.Ident))))
                   ww1
                   ww2 }) -}
1945f50daf5e604ccec33d9961a2c29f
  $scompleteFilename4 ::
    System.Console.Haskeline.Completion.CompletionFunc
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamCBN,
           Data.Map.Internal.Map
             Environment.Ident
             (LamFunSyntax.Defn_ 'LamFunSyntax.LamCBN Environment.Ident)))
         GHC.Types.IO)
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 System.Console.Haskeline.Completion.$wcompleteFilename
                   @ (Control.Monad.Trans.State.Strict.StateT
                        (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamCBN,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamCBN Environment.Ident)))
                        GHC.Types.IO)
                   (Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT
                      @ (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamCBN,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamCBN Environment.Ident))))
                   ww1
                   ww2 }) -}
cd839328d042d53e602c7150ee20bba8
  $scompleteFilename5 ::
    System.Console.Haskeline.Completion.CompletionFunc
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamArray,
           Data.Map.Internal.Map
             Environment.Ident
             (LamFunSyntax.Defn_ 'LamFunSyntax.LamArray Environment.Ident)))
         GHC.Types.IO)
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w1 :: (GHC.Base.String, GHC.Base.String)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 System.Console.Haskeline.Completion.$wcompleteFilename
                   @ (Control.Monad.Trans.State.Strict.StateT
                        (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamArray,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamArray Environment.Ident)))
                        GHC.Types.IO)
                   (Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT
                      @ (Main.Settings,
                         (LamFunInterpreter.GlobEnv 'LamFunSyntax.LamArray,
                          Data.Map.Internal.Map
                            Environment.Ident
                            (LamFunSyntax.Defn_ 'LamFunSyntax.LamArray Environment.Ident))))
                   ww1
                   ww2 }) -}
3aae4007ec859bb3d81622fd25e4359f
  $tc'Settings :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   100173331511018859##
                   7665572576897397539##
                   Main.$trModule
                   Main.$tc'Settings2
                   0#
                   Main.$tc'Settings1) -}
94b983e754fe60f08742ef223e1016b2
  $tc'Settings1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
b654077e9d6f1414051767ad1b94983e
  $tc'Settings2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tc'Settings3) -}
57cc943659b7766a05dc7398e5de7962
  $tc'Settings3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Settings"#) -}
4a88ba9f007d9d2e3f4d545d3668215a
  $tcSettings :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3156194968524543507##
                   10796635826944817152##
                   Main.$trModule
                   Main.$tcSettings1
                   0#
                   GHC.Types.krep$*) -}
f10036bafc69d4d101118dba8103f9ef
  $tcSettings1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$tcSettings2) -}
4aa2be0a4649af98b66fad4f828d34cf
  $tcSettings2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Settings"#) -}
be86c9d078d3acbf19ba91fe74a24273
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule3 Main.$trModule1) -}
b09d86f2c49dd5176b544d8d13ddb6c5
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule2) -}
e5875966b74dad2d29772660b8a75e33
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Main"#) -}
23b03bd7d075a00f5ad1ee10e6add7b8
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Main.$trModule4) -}
d026be77cb9ced20e35a61514e0458aa
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
b0f37d9e147e609d4b31de3d4b2a36e6
  $wpoly_go13 ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Map.Internal.Map Environment.Ident a
    -> GHC.Maybe.Maybe a
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [2] -}
1fb833cf361c40bd57024e1cbcbc2b40
  type Repl (v :: LamFunSyntax.Version) a =
    System.Console.Repline.HaskelineT
      (Control.Monad.Trans.State.Strict.StateT
         (Main.Settings,
          (LamFunInterpreter.GlobEnv v, LamFunInterpreter.RawEnv v))
         GHC.Types.IO)
      a
b0335e0e9ce72eed6422f48e67736de0
  data Settings
    = Settings {currentFile :: GHC.Maybe.Maybe GHC.IO.FilePath,
                verbose :: GHC.Types.Bool,
                buffer :: [GHC.Base.String]}
b0335e0e9ce72eed6422f48e67736de0
  buffer :: Main.Settings -> [GHC.Base.String]
  RecSel Left Main.Settings
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Settings) ->
                 case ds of wild { Main.Settings ds1 ds2 ds3 -> ds3 }) -}
b0335e0e9ce72eed6422f48e67736de0
  currentFile :: Main.Settings -> GHC.Maybe.Maybe GHC.IO.FilePath
  RecSel Left Main.Settings
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Settings) ->
                 case ds of wild { Main.Settings ds1 ds2 ds3 -> ds1 }) -}
07e923e6802d119eb9a1b2e1fbb77df5
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
db9c71894c7407d4fa8e54b03c41d625
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case GHC.IO.Encoding.getLocaleEncoding1 of wild { (,) getLocaleEncoding3 setLocaleEncoding1 ->
                 case (setLocaleEncoding1 GHC.IO.Encoding.UTF8.utf8)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Prim.catch#
                        @ (GHC.Types.IO [GHC.Types.Char])
                        @ GHC.Exception.Type.SomeException
                        Main.main15
                        Main.main6
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 `cast` (GHC.Types.N:IO[0] <[GHC.Types.Char]>_R)
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 Main.main5 ipv5 GHC.Types.False Main.main2 ipv4 } } } }) -}
0efae61ecf7363f84e7b6e0b72d59fd5
  main10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   Main.main14
                   Main.main11) -}
2ef66dd639eea849c3f9c9b06cf231eb
  main11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   Main.main13
                   Main.main12) -}
c4b19fded18bf04d9920b0d425fd9f32
  main12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackAppendCString#
                   Main.main9
                   Utils.normal) -}
3d1be2d8f17250753a8569fc21d6b420
  main13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\ESC[7m"#) -}
da2567ccea873448027d543500958a3f
  main14 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Settings file not found ... defaulting to "#) -}
9524cad4d72550563a1e8ccba3f9c901
  main15 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Types.IO [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        Main.main18
                        GHC.IO.IOMode.ReadMode
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Internals.withAllHandles__1
                        GHC.IO.Handle.hSetNewlineMode2
                        ipv1
                        Main.main17
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.N:IO[0] <GHC.IO.Handle.Types.Handle__>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case (GHC.IO.Handle.Text.hPutStr'
                         GHC.IO.Handle.FD.stdout
                         (GHC.CString.unpackAppendCString#
                            Main.main16
                            (GHC.CString.unpackAppendCString#
                               Main.main13
                               (GHC.Base.++ @ GHC.Types.Char ipv5 Utils.normal)))
                         GHC.Types.True)
                        `cast`
                      (GHC.Types.N:IO[0] <()>_R)
                        ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                 (# ipv6,
                    (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) -> (# s1, ipv5 #))
                      `cast`
                    (Sym (GHC.Types.N:IO[0] <[GHC.Types.Char]>_R)) #) } } } }) -}
ea19bc54a54d27bb50c6731218feaf8c
  main16 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Found settings file ... setting language to "#) -}
46634e24b57bf6730468bf7ee9604f7e
  main17 ::
    GHC.IO.Handle.Types.Handle__
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.IO.Handle.Types.Handle__ #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (h_ :: GHC.IO.Handle.Types.Handle__)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case h_ of wild { GHC.IO.Handle.Types.Handle__ dev enc_state dec_state $dIODevice $dBufferedIO $dTypeable ds ds1 dt ds2 dt1 dt2 dt3 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 case GHC.IO.Handle.Internals.flushBuffer1
                        wild
                        eta of ds9 { (#,#) ipv ipv1 ->
                 (# ipv,
                    GHC.IO.Handle.Types.Handle__
                      @ dev
                      @ enc_state
                      @ dec_state
                      $dIODevice
                      $dBufferedIO
                      $dTypeable
                      ds
                      ds1
                      dt
                      ds2
                      dt1
                      dt2
                      dt3
                      ds3
                      ds4
                      ds5
                      GHC.IO.Handle.Types.CRLF
                      GHC.IO.Handle.Types.LF
                      ds8 #) } }) -}
693a634bdc2f61ac370a46b027668f48
  main18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.main19) -}
f174e8c8903d184a455531cf85424bfb
  main19 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (".lamfun"#) -}
775cd77569a1552600dbb7fbee0e63e4
  main2 :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: (GHC.IO.Handle.Text.hPutStr'
                   GHC.IO.Handle.FD.stdout
                   Main.main3
                   GHC.Types.True) -}
c3caf8445e9805d7a47ec6672f87e38f
  main20 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
601bff620384229db3e6daf9f0816257
  main3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCStringUtf8# Main.main4) -}
26e75409f07120712d9e8c62580a74a8
  main4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\n\
                 \  $$$$\\        $$$$$$$$\\                     \n\
                 \    $$ \\       $$  _____|                    \n\
                 \     $$ \\      $$ |    $$\\   $$\\ $$$$$$$\\  \n\
                 \     $$$ \\     $$$$$\\  $$ |  $$ |$$  __$$\\ \n\
                 \    $$ $$ \\    $$  __| $$ |  $$ |$$ |  $$ |\n\
                 \   $$ / $$ \\   $$ |    $$ |  $$ |$$ |  $$ |\n\
                 \ $$$ /   $$$\\  $$ |    \\$$$$$$  |$$ |  $$ |\n\
                 \ \\___|   \\___| \\__|     \\______/ \\__|  \\__|\n\
                 \\n\
                 \Welcome to \\206\\187Fun v3.14.1 ...\n"#) -}
991eea83d8be6f22d0c8fae6aa3c5a14
  main5 ::
    GHC.Base.String
    -> GHC.Types.Bool
    -> GHC.Types.IO ()
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <S,U><L,U><L,C(U(U,U))><S,U> -}
243bd57bced5ff58c45eefc3f5480b8e
  main6 ::
    GHC.Exception.Type.SomeException
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Types.IO [GHC.Types.Char] #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: (\ (e1 :: GHC.Exception.Type.SomeException)[OneShot]
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case e1 of wild { GHC.Exception.Type.SomeException e2 $dException1 e3 ->
                 case Data.Typeable.Internal.sameTypeRep
                        @ *
                        @ *
                        @ e2
                        @ GHC.IO.Exception.IOException
                        (GHC.Exception.Type.$p1Exception @ e2 $dException1)
                          `cast`
                        (Data.Typeable.Internal.N:Typeable[0] <*>_N <e2>_N)
                        GHC.IO.Exception.$fExceptionIOException4 of wild1 {
                   GHC.Types.False
                   -> GHC.Prim.raiseIO#
                        @ GHC.Exception.Type.SomeException
                        @ (GHC.Types.IO [GHC.Types.Char])
                        wild
                        eta
                   GHC.Types.True
                   -> case (GHC.IO.Handle.Text.hPutStr'
                              GHC.IO.Handle.FD.stdout
                              Main.main10
                              GHC.Types.True)
                             `cast`
                           (GHC.Types.N:IO[0] <()>_R)
                             eta of ds1 { (#,#) ipv ipv1 ->
                      (# ipv,
                         Main.main7
                           `cast`
                         (Sym (GHC.Types.N:IO[0] <[GHC.Types.Char]>_R)) #) } } }) -}
b7a5bb26f28252e3682c7ca0c6bc6348
  main7 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, [GHC.Types.Char] #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 (# s1, Main.main8 #)) -}
f58f10b8801e7e0d0ef5f99587d0c2ff
  main8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Main.main9) -}
1f13be5759202d6d21db3f8656e9dda6
  main9 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamRec"#) -}
b0335e0e9ce72eed6422f48e67736de0
  verbose :: Main.Settings -> GHC.Types.Bool
  RecSel Left Main.Settings
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Main.Settings) ->
                 case ds of wild { Main.Settings ds1 ds2 ds3 -> ds2 }) -}
"SPEC/Main $fApplicativeStateT @ IO _" [orphan] forall @ s
                                                       (v1 :: GHC.Base.Monad GHC.Types.IO)
                                                       (v :: GHC.Base.Functor GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fApplicativeStateT @ GHC.Types.IO
                                                       @ s
                                                       v
                                                       v1
  = Main.$s$fApplicativeStateT @ s
"SPEC/Main $fApplicativeStateT_$c*> @ IO _" [orphan] forall @ s
                                                            ($dMonad :: GHC.Base.Monad GHC.Types.IO)
                                                            ($dFunctor :: GHC.Base.Functor
                                                                            GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fApplicativeStateT_$c*> @ GHC.Types.IO
                                                            @ s
                                                            $dFunctor
                                                            $dMonad
  = Main.$s$fApplicativeStateT_$s$fApplicativeStateT_$c*> @ s
"SPEC/Main $fApplicativeStateT_$c<*> @ IO _" [orphan] forall @ s
                                                             ($dMonad :: GHC.Base.Monad
                                                                           GHC.Types.IO)
                                                             ($dFunctor :: GHC.Base.Functor
                                                                             GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fApplicativeStateT_$c<*> @ GHC.Types.IO
                                                             @ s
                                                             $dFunctor
                                                             $dMonad
  = Main.$s$fApplicativeStateT_$s$fApplicativeStateT_$c<*> @ s
"SPEC/Main $fApplicativeStateT_$cpure @ IO _" [orphan] forall @ s
                                                              ($dMonad :: GHC.Base.Monad
                                                                            GHC.Types.IO)
                                                              ($dFunctor :: GHC.Base.Functor
                                                                              GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fApplicativeStateT_$cpure @ GHC.Types.IO
                                                              @ s
                                                              $dFunctor
                                                              $dMonad
  = Main.$s$fApplicativeStateT_$s$fApplicativeStateT_$cpure @ s
"SPEC/Main $fEqProgram_ @ (Token Text) _" [orphan] forall @ v :: LamFunSyntax.Version
                                                          (v1 :: GHC.Classes.Eq
                                                                   (LamFunLexer.Token
                                                                      Data.Text.Internal.Text))
  LamFunSyntax.$fEqProgram_ @ (LamFunLexer.Token
                                 Data.Text.Internal.Text)
                            @ v
                            v1
  = Main.$s$fEqProgram_ @ v
"SPEC/Main $fEqToken @ Text" [orphan] forall (v :: GHC.Classes.Eq
                                                     Data.Text.Internal.Text)
  LamFunLexer.$fEqToken @ Data.Text.Internal.Text v
  = Main.$s$fEqProgram__$s$fEqToken
"SPEC/Main $fEqToken_$c/= @ Text" [orphan] forall ($dEq :: GHC.Classes.Eq
                                                             Data.Text.Internal.Text)
  LamFunLexer.$fEqToken_$c/= @ Data.Text.Internal.Text $dEq
  = Main.$s$fEqProgram__$s$fEqToken_$c/=
"SPEC/Main $fEq[] @ (Program_ 'LamArray (Token Text))" [orphan] forall (v :: GHC.Classes.Eq
                                                                               (LamFunSyntax.Program_
                                                                                  'LamFunSyntax.LamArray
                                                                                  (LamFunLexer.Token
                                                                                     Data.Text.Internal.Text)))
  GHC.Classes.$fEq[] @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                     v
  = Main.$s$fEq[]5
"SPEC/Main $fEq[] @ (Program_ 'LamCBN (Token Text))" [orphan] forall (v :: GHC.Classes.Eq
                                                                             (LamFunSyntax.Program_
                                                                                'LamFunSyntax.LamCBN
                                                                                (LamFunLexer.Token
                                                                                   Data.Text.Internal.Text)))
  GHC.Classes.$fEq[] @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                     v
  = Main.$s$fEq[]4
"SPEC/Main $fEq[] @ (Program_ 'LamCBV (Token Text))" [orphan] forall (v :: GHC.Classes.Eq
                                                                             (LamFunSyntax.Program_
                                                                                'LamFunSyntax.LamCBV
                                                                                (LamFunLexer.Token
                                                                                   Data.Text.Internal.Text)))
  GHC.Classes.$fEq[] @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                     v
  = Main.$s$fEq[]3
"SPEC/Main $fEq[] @ (Program_ 'LamMem (Token Text))" [orphan] forall (v :: GHC.Classes.Eq
                                                                             (LamFunSyntax.Program_
                                                                                'LamFunSyntax.LamMem
                                                                                (LamFunLexer.Token
                                                                                   Data.Text.Internal.Text)))
  GHC.Classes.$fEq[] @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                     v
  = Main.$s$fEq[]2
"SPEC/Main $fEq[] @ (Program_ 'LamNat (Token Text))" [orphan] forall (v :: GHC.Classes.Eq
                                                                             (LamFunSyntax.Program_
                                                                                'LamFunSyntax.LamNat
                                                                                (LamFunLexer.Token
                                                                                   Data.Text.Internal.Text)))
  GHC.Classes.$fEq[] @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                     v
  = Main.$s$fEq[]
"SPEC/Main $fEq[] @ (Program_ 'LamRec (Token Text))" [orphan] forall (v :: GHC.Classes.Eq
                                                                             (LamFunSyntax.Program_
                                                                                'LamFunSyntax.LamRec
                                                                                (LamFunLexer.Token
                                                                                   Data.Text.Internal.Text)))
  GHC.Classes.$fEq[] @ (LamFunSyntax.Program_
                          'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                     v
  = Main.$s$fEq[]1
"SPEC/Main $fFunctorStateT @ IO _" [orphan] forall @ s
                                                   (v :: GHC.Base.Functor GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fFunctorStateT @ GHC.Types.IO
                                                   @ s
                                                   v
  = Main.$s$fApplicativeStateT_$s$fFunctorStateT @ s
"SPEC/Main $fMonadIOStateT @ IO _" [orphan] forall @ s
                                                   (v :: Control.Monad.IO.Class.MonadIO
                                                           GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fMonadIOStateT @ GHC.Types.IO
                                                   @ s
                                                   v
  = Main.$s$fMonadExceptionStateT_$s$fMonadIOStateT @ s
"SPEC/Main $fMonadStateT @ IO _" [orphan] forall @ s
                                                 (v :: GHC.Base.Monad GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fMonadStateT @ GHC.Types.IO @ s v
  = Main.$s$fMonadExceptionStateT_$s$fMonadStateT @ s
"SPEC/Main $fMonadStateT_$c>> @ IO _" [orphan] forall @ s
                                                      ($dMonad :: GHC.Base.Monad GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fMonadStateT_$c>> @ GHC.Types.IO
                                                      @ s
                                                      $dMonad
  = Main.$s$fMonadExceptionStateT_$s$fMonadStateT_$c>> @ s
"SPEC/Main $fMonadStateT_$c>>= @ IO _" [orphan] forall @ s
                                                       ($dMonad :: GHC.Base.Monad GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fMonadStateT_$c>>= @ GHC.Types.IO
                                                       @ s
                                                       $dMonad
  = Main.$s$fMonadExceptionStateT_$s$fMonadStateT_$c>>= @ s
"SPEC/Main $fMonadStateT_$cfail @ IO _" [orphan] forall @ s
                                                        ($dMonad :: GHC.Base.Monad GHC.Types.IO)
  Control.Monad.Trans.State.Strict.$fMonadStateT_$cfail @ GHC.Types.IO
                                                        @ s
                                                        $dMonad
  = Main.$s$fMonadExceptionStateT_$s$fMonadStateT_$cfail @ s
"SPEC/Main $fOrdProgram_ @ (Token Text) _" [orphan] forall @ v :: LamFunSyntax.Version
                                                           (v1 :: GHC.Classes.Ord
                                                                    (LamFunLexer.Token
                                                                       Data.Text.Internal.Text))
  LamFunSyntax.$fOrdProgram_ @ (LamFunLexer.Token
                                  Data.Text.Internal.Text)
                             @ v
                             v1
  = Main.$s$fOrdProgram_ @ v
"SPEC/Main $fOrdToken @ Text" [orphan] forall (v :: GHC.Classes.Ord
                                                      Data.Text.Internal.Text)
  LamFunLexer.$fOrdToken @ Data.Text.Internal.Text v
  = Main.$s$fOrdProgram__$s$fOrdToken
"SPEC/Main $fOrdToken_$ccompare @ Text" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                    Data.Text.Internal.Text)
  LamFunLexer.$fOrdToken_$ccompare @ Data.Text.Internal.Text $dOrd
  = Main.$s$fOrdToken_$ccompare
"SPEC/Main $fOrdToken_$cmax @ Text" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                Data.Text.Internal.Text)
  LamFunLexer.$fOrdToken_$cmax @ Data.Text.Internal.Text $dOrd
  = Main.$s$fOrdToken_$cmax
"SPEC/Main $fOrdToken_$cmin @ Text" [orphan] forall ($dOrd :: GHC.Classes.Ord
                                                                Data.Text.Internal.Text)
  LamFunLexer.$fOrdToken_$cmin @ Data.Text.Internal.Text $dOrd
  = Main.$s$fOrdToken_$cmin
"SPEC/Main $fOrd[] @ (Program_ 'LamArray (Token Text))" [orphan] forall (v :: GHC.Classes.Ord
                                                                                (LamFunSyntax.Program_
                                                                                   'LamFunSyntax.LamArray
                                                                                   (LamFunLexer.Token
                                                                                      Data.Text.Internal.Text)))
  GHC.Classes.$fOrd[] @ (LamFunSyntax.Program_
                           'LamFunSyntax.LamArray (LamFunLexer.Token Data.Text.Internal.Text))
                      v
  = Main.$s$fOrd[]5
"SPEC/Main $fOrd[] @ (Program_ 'LamCBN (Token Text))" [orphan] forall (v :: GHC.Classes.Ord
                                                                              (LamFunSyntax.Program_
                                                                                 'LamFunSyntax.LamCBN
                                                                                 (LamFunLexer.Token
                                                                                    Data.Text.Internal.Text)))
  GHC.Classes.$fOrd[] @ (LamFunSyntax.Program_
                           'LamFunSyntax.LamCBN (LamFunLexer.Token Data.Text.Internal.Text))
                      v
  = Main.$s$fOrd[]4
"SPEC/Main $fOrd[] @ (Program_ 'LamCBV (Token Text))" [orphan] forall (v :: GHC.Classes.Ord
                                                                              (LamFunSyntax.Program_
                                                                                 'LamFunSyntax.LamCBV
                                                                                 (LamFunLexer.Token
                                                                                    Data.Text.Internal.Text)))
  GHC.Classes.$fOrd[] @ (LamFunSyntax.Program_
                           'LamFunSyntax.LamCBV (LamFunLexer.Token Data.Text.Internal.Text))
                      v
  = Main.$s$fOrd[]3
"SPEC/Main $fOrd[] @ (Program_ 'LamMem (Token Text))" [orphan] forall (v :: GHC.Classes.Ord
                                                                              (LamFunSyntax.Program_
                                                                                 'LamFunSyntax.LamMem
                                                                                 (LamFunLexer.Token
                                                                                    Data.Text.Internal.Text)))
  GHC.Classes.$fOrd[] @ (LamFunSyntax.Program_
                           'LamFunSyntax.LamMem (LamFunLexer.Token Data.Text.Internal.Text))
                      v
  = Main.$s$fOrd[]2
"SPEC/Main $fOrd[] @ (Program_ 'LamNat (Token Text))" [orphan] forall (v :: GHC.Classes.Ord
                                                                              (LamFunSyntax.Program_
                                                                                 'LamFunSyntax.LamNat
                                                                                 (LamFunLexer.Token
                                                                                    Data.Text.Internal.Text)))
  GHC.Classes.$fOrd[] @ (LamFunSyntax.Program_
                           'LamFunSyntax.LamNat (LamFunLexer.Token Data.Text.Internal.Text))
                      v
  = Main.$s$fOrd[]
"SPEC/Main $fOrd[] @ (Program_ 'LamRec (Token Text))" [orphan] forall (v :: GHC.Classes.Ord
                                                                              (LamFunSyntax.Program_
                                                                                 'LamFunSyntax.LamRec
                                                                                 (LamFunLexer.Token
                                                                                    Data.Text.Internal.Text)))
  GHC.Classes.$fOrd[] @ (LamFunSyntax.Program_
                           'LamFunSyntax.LamRec (LamFunLexer.Token Data.Text.Internal.Text))
                      v
  = Main.$s$fOrd[]1
"SPEC/Main completeFilename @ (StateT
                                (Settings, (GlobEnv 'LamArray, Map Ident (Defn_ 'LamArray Ident)))
                                IO)" [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                                                                 (Control.Monad.Trans.State.Strict.StateT
                                                                                                                                                                                                    (Main.Settings,
                                                                                                                                                                                                     (LamFunInterpreter.GlobEnv
                                                                                                                                                                                                        'LamFunSyntax.LamArray,
                                                                                                                                                                                                      Data.Map.Internal.Map
                                                                                                                                                                                                        Environment.Ident
                                                                                                                                                                                                        (LamFunSyntax.Defn_
                                                                                                                                                                                                           'LamFunSyntax.LamArray
                                                                                                                                                                                                           Environment.Ident)))
                                                                                                                                                                                                    GHC.Types.IO))
  System.Console.Haskeline.Completion.completeFilename @ (Control.Monad.Trans.State.Strict.StateT
                                                            (Main.Settings,
                                                             (LamFunInterpreter.GlobEnv
                                                                'LamFunSyntax.LamArray,
                                                              Data.Map.Internal.Map
                                                                Environment.Ident
                                                                (LamFunSyntax.Defn_
                                                                   'LamFunSyntax.LamArray
                                                                   Environment.Ident)))
                                                            GHC.Types.IO)
                                                       w
  = Main.$scompleteFilename5
"SPEC/Main completeFilename @ (StateT
                                (Settings, (GlobEnv 'LamCBN, Map Ident (Defn_ 'LamCBN Ident))) IO)" [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                             (Control.Monad.Trans.State.Strict.StateT
                                                                                                                                                                (Main.Settings,
                                                                                                                                                                 (LamFunInterpreter.GlobEnv
                                                                                                                                                                    'LamFunSyntax.LamCBN,
                                                                                                                                                                  Data.Map.Internal.Map
                                                                                                                                                                    Environment.Ident
                                                                                                                                                                    (LamFunSyntax.Defn_
                                                                                                                                                                       'LamFunSyntax.LamCBN
                                                                                                                                                                       Environment.Ident)))
                                                                                                                                                                GHC.Types.IO))
  System.Console.Haskeline.Completion.completeFilename @ (Control.Monad.Trans.State.Strict.StateT
                                                            (Main.Settings,
                                                             (LamFunInterpreter.GlobEnv
                                                                'LamFunSyntax.LamCBN,
                                                              Data.Map.Internal.Map
                                                                Environment.Ident
                                                                (LamFunSyntax.Defn_
                                                                   'LamFunSyntax.LamCBN
                                                                   Environment.Ident)))
                                                            GHC.Types.IO)
                                                       w
  = Main.$scompleteFilename4
"SPEC/Main completeFilename @ (StateT
                                (Settings, (GlobEnv 'LamCBV, Map Ident (Defn_ 'LamCBV Ident))) IO)" [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                             (Control.Monad.Trans.State.Strict.StateT
                                                                                                                                                                (Main.Settings,
                                                                                                                                                                 (LamFunInterpreter.GlobEnv
                                                                                                                                                                    'LamFunSyntax.LamCBV,
                                                                                                                                                                  Data.Map.Internal.Map
                                                                                                                                                                    Environment.Ident
                                                                                                                                                                    (LamFunSyntax.Defn_
                                                                                                                                                                       'LamFunSyntax.LamCBV
                                                                                                                                                                       Environment.Ident)))
                                                                                                                                                                GHC.Types.IO))
  System.Console.Haskeline.Completion.completeFilename @ (Control.Monad.Trans.State.Strict.StateT
                                                            (Main.Settings,
                                                             (LamFunInterpreter.GlobEnv
                                                                'LamFunSyntax.LamCBV,
                                                              Data.Map.Internal.Map
                                                                Environment.Ident
                                                                (LamFunSyntax.Defn_
                                                                   'LamFunSyntax.LamCBV
                                                                   Environment.Ident)))
                                                            GHC.Types.IO)
                                                       w
  = Main.$scompleteFilename3
"SPEC/Main completeFilename @ (StateT
                                (Settings, (GlobEnv 'LamMem, Map Ident (Defn_ 'LamMem Ident))) IO)" [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                             (Control.Monad.Trans.State.Strict.StateT
                                                                                                                                                                (Main.Settings,
                                                                                                                                                                 (LamFunInterpreter.GlobEnv
                                                                                                                                                                    'LamFunSyntax.LamMem,
                                                                                                                                                                  Data.Map.Internal.Map
                                                                                                                                                                    Environment.Ident
                                                                                                                                                                    (LamFunSyntax.Defn_
                                                                                                                                                                       'LamFunSyntax.LamMem
                                                                                                                                                                       Environment.Ident)))
                                                                                                                                                                GHC.Types.IO))
  System.Console.Haskeline.Completion.completeFilename @ (Control.Monad.Trans.State.Strict.StateT
                                                            (Main.Settings,
                                                             (LamFunInterpreter.GlobEnv
                                                                'LamFunSyntax.LamMem,
                                                              Data.Map.Internal.Map
                                                                Environment.Ident
                                                                (LamFunSyntax.Defn_
                                                                   'LamFunSyntax.LamMem
                                                                   Environment.Ident)))
                                                            GHC.Types.IO)
                                                       w
  = Main.$scompleteFilename2
"SPEC/Main completeFilename @ (StateT
                                (Settings, (GlobEnv 'LamNat, Map Ident (Defn_ 'LamNat Ident))) IO)" [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                             (Control.Monad.Trans.State.Strict.StateT
                                                                                                                                                                (Main.Settings,
                                                                                                                                                                 (LamFunInterpreter.GlobEnv
                                                                                                                                                                    'LamFunSyntax.LamNat,
                                                                                                                                                                  Data.Map.Internal.Map
                                                                                                                                                                    Environment.Ident
                                                                                                                                                                    (LamFunSyntax.Defn_
                                                                                                                                                                       'LamFunSyntax.LamNat
                                                                                                                                                                       Environment.Ident)))
                                                                                                                                                                GHC.Types.IO))
  System.Console.Haskeline.Completion.completeFilename @ (Control.Monad.Trans.State.Strict.StateT
                                                            (Main.Settings,
                                                             (LamFunInterpreter.GlobEnv
                                                                'LamFunSyntax.LamNat,
                                                              Data.Map.Internal.Map
                                                                Environment.Ident
                                                                (LamFunSyntax.Defn_
                                                                   'LamFunSyntax.LamNat
                                                                   Environment.Ident)))
                                                            GHC.Types.IO)
                                                       w
  = Main.$scompleteFilename
"SPEC/Main completeFilename @ (StateT
                                (Settings, (GlobEnv 'LamRec, Map Ident (Defn_ 'LamRec Ident))) IO)" [2] forall (w :: Control.Monad.IO.Class.MonadIO
                                                                                                                                                             (Control.Monad.Trans.State.Strict.StateT
                                                                                                                                                                (Main.Settings,
                                                                                                                                                                 (LamFunInterpreter.GlobEnv
                                                                                                                                                                    'LamFunSyntax.LamRec,
                                                                                                                                                                  Data.Map.Internal.Map
                                                                                                                                                                    Environment.Ident
                                                                                                                                                                    (LamFunSyntax.Defn_
                                                                                                                                                                       'LamFunSyntax.LamRec
                                                                                                                                                                       Environment.Ident)))
                                                                                                                                                                GHC.Types.IO))
  System.Console.Haskeline.Completion.completeFilename @ (Control.Monad.Trans.State.Strict.StateT
                                                            (Main.Settings,
                                                             (LamFunInterpreter.GlobEnv
                                                                'LamFunSyntax.LamRec,
                                                              Data.Map.Internal.Map
                                                                Environment.Ident
                                                                (LamFunSyntax.Defn_
                                                                   'LamFunSyntax.LamRec
                                                                   Environment.Ident)))
                                                            GHC.Types.IO)
                                                       w
  = Main.$scompleteFilename1
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

