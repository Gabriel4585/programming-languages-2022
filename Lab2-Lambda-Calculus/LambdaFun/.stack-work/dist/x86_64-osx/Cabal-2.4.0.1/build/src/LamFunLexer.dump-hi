
==================== FINAL INTERFACE ====================
2019-11-21 22:26:13.677375 UTC

interface LamFun-3.14.1-1NElG62CogO50XNaLIVWxW:LamFunLexer [family instance module] 8064
  interface hash: 8de80de86bbbedd613db27d3b52b8ffa
  ABI hash: 909df15affead5866583bc209f6af47c
  export-list hash: f670cb252481636297bb0f04d00aa46e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: bc7eddde20ba1328cf9f71d8be522721
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  LamFunLexer.defaultPosition
  LamFunLexer.reservedKeywords
  LamFunLexer.tokenize
  LamFunLexer.Col{LamFunLexer.Col}
  LamFunLexer.Row{LamFunLexer.Row}
  LamFunLexer.Token{LamFunLexer.Token colEnd colStart rowEnd rowStart unTok}
module dependencies:
package dependencies: array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      ghc-prim-0.5.3 hashable-1.2.7.0 integer-gmp-1.0.2.0 mtl-2.2.2
                      string-conv-0.1.2 text-1.2.3.1 transformers-0.5.6.2
orphans: transformers-0.5.6.2:Control.Monad.Trans.Error
         hashable-1.2.7.0:Data.Hashable.Generic text-1.2.3.1:Data.Text.Lazy
         text-1.2.3.1:Data.Text binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
import  -/  base-4.12.0.0:Control.Arrow cda881e865dd3141fb08ed18f2efcca7
import  -/  base-4.12.0.0:Data.Bifunctor c6b94a4350abddc02c676eba95d481f0
import  -/  base-4.12.0.0:Data.Functor 069b2025a03e32fd228e74a86a58a075
import  -/  base-4.12.0.0:Data.List 17d0c71c557e42abe196f130788fd997
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.OldList e931cf456dc87f11ee6e6fb153bca23e
import  -/  base-4.12.0.0:Data.String fa00d4c51cd8d22ee4f54a25f9e9c97d
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Generics 2b3b2e72be66983021f8ad0c2edcf290
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  hashable-1.2.7.0:Data.Hashable 52de7ce057cbb2207689571a9d126e28
import  -/  hashable-1.2.7.0:Data.Hashable.Class b7859f24482b682acf3c154276b2252b
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 6d87087aea24143d2650f78480d954a3
import  -/  mtl-2.2.2:Control.Monad.State 753def63fe8e937dc636f11e5230745a
import  -/  mtl-2.2.2:Control.Monad.State.Class 243c828469104fb94563be0ea268f418
import  -/  string-conv-0.1.2:Data.String.Conv 5e3d04602479634a311e8f9d4932abfb
import  -/  text-1.2.3.1:Data.Text 681b9c3df5b4e4b4e23ef5f840f0b692
import  -/  text-1.2.3.1:Data.Text.Internal 537e168590e8068f673f691833f78483
import  -/  text-1.2.3.1:Data.Text.Show b788b7edd0f190b1a7c4f4aba0e35f18
import  -/  transformers-0.5.6.2:Control.Monad.Trans.State.Lazy 0c22827dedcb94d04bf072c00f8e95c2
f2c5a98949fb07f270f36c9e0675ac4d
  $fEqCol :: GHC.Classes.Eq LamFunLexer.Col
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Col
                  GHC.Classes.eqInt
                    `cast`
                  (Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.neInt
                    `cast`
                  (Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R <GHC.Types.Bool>_R) -}
73f02fd9088bf7097a9de5a2df4483d2
  $fEqDropOrKeepLabel :: GHC.Classes.Eq LamFunLexer.DropOrKeepLabel
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.DropOrKeepLabel
                  LamFunLexer.$fEqDropOrKeepLabel_$c==
                  LamFunLexer.$fEqDropOrKeepLabel_$c/= -}
73f02fd9088bf7097a9de5a2df4483d2
  $fEqDropOrKeepLabel_$c/= ::
    LamFunLexer.DropOrKeepLabel
    -> LamFunLexer.DropOrKeepLabel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x1 :: LamFunLexer.DropOrKeepLabel)
                   (y :: LamFunLexer.DropOrKeepLabel) ->
                 case x1 of wild {
                   LamFunLexer.Drop
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunLexer.Drop -> GHC.Types.False }
                   LamFunLexer.Keep
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunLexer.Keep -> GHC.Types.False }
                   LamFunLexer.New
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        LamFunLexer.New -> GHC.Types.False } }) -}
73f02fd9088bf7097a9de5a2df4483d2
  $fEqDropOrKeepLabel_$c== ::
    LamFunLexer.DropOrKeepLabel
    -> LamFunLexer.DropOrKeepLabel -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: LamFunLexer.DropOrKeepLabel)
                   (ds1 :: LamFunLexer.DropOrKeepLabel) ->
                 case ds of wild {
                   LamFunLexer.Drop
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunLexer.Drop -> GHC.Types.True }
                   LamFunLexer.Keep
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunLexer.Keep -> GHC.Types.True }
                   LamFunLexer.New
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        LamFunLexer.New -> GHC.Types.True } }) -}
332c1546bd09260727a773e99e195081
  $fEqRow :: GHC.Classes.Eq LamFunLexer.Row
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Row
                  GHC.Classes.eqInt
                    `cast`
                  (Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R <GHC.Types.Bool>_R)
                  GHC.Classes.neInt
                    `cast`
                  (Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R <GHC.Types.Bool>_R) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fEqToken ::
    GHC.Classes.Eq a => GHC.Classes.Eq (LamFunLexer.Token a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Eq a).
                  @ (LamFunLexer.Token a)
                  (LamFunLexer.$fEqToken_$c== @ a v)
                  (LamFunLexer.$fEqToken_$c/= @ a v) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fEqToken_$c/= ::
    GHC.Classes.Eq a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.==
                        @ a
                        $dEq
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fEqToken_$c== ::
    GHC.Classes.Eq a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dEq :: GHC.Classes.Eq a)
                   (t1 :: LamFunLexer.Token a)
                   (t2 :: LamFunLexer.Token a) ->
                 GHC.Classes.==
                   @ a
                   $dEq
                   (case t1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                   (case t2 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                    ds })) -}
8f2332b352b177c2329324164108499b
  $fFunctorDropOrKeep :: GHC.Base.Functor LamFunLexer.DropOrKeep
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.DropOrKeep
                  LamFunLexer.$fFunctorDropOrKeep_$cfmap
                  LamFunLexer.$fFunctorDropOrKeep_$c<$ -}
8f2332b352b177c2329324164108499b
  $fFunctorDropOrKeep_$c<$ ::
    a -> LamFunLexer.DropOrKeep b -> LamFunLexer.DropOrKeep a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (z :: a) (ds :: LamFunLexer.DropOrKeep b) ->
                 case ds of wild { LamFunLexer.DropOrKeep a1 a2 ->
                 LamFunLexer.DropOrKeep @ a a1 z }) -}
8f2332b352b177c2329324164108499b
  $fFunctorDropOrKeep_$cfmap ::
    (a -> b) -> LamFunLexer.DropOrKeep a -> LamFunLexer.DropOrKeep b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: LamFunLexer.DropOrKeep a) ->
                 case ds of wild { LamFunLexer.DropOrKeep a1 a2 ->
                 LamFunLexer.DropOrKeep @ b a1 (f a2) }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fGenericToken :: GHC.Generics.Generic (LamFunLexer.Token a)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ a.
                  @ (LamFunLexer.Token a)
                  (LamFunLexer.$fGenericToken1 @ a)
                    `cast`
                  (forall (x1 :: <*>_N).
                   <LamFunLexer.Token a>_R
                   ->_R (Sym (GHC.Generics.N:M1[0]
                                  <*>_N
                                  <GHC.Generics.D>_P
                                  <'GHC.Generics.MetaData
                                     "Token"
                                     "LamFunLexer"
                                     "LamFun-3.14.1-1NElG62CogO50XNaLIVWxW"
                                     'GHC.Types.False>_P
                                  <GHC.Generics.M1
                                     GHC.Generics.C
                                     ('GHC.Generics.MetaCons
                                        "Token" 'GHC.Generics.PrefixI 'GHC.Types.True)
                                     ((GHC.Generics.M1
                                         GHC.Generics.S
                                         ('GHC.Generics.MetaSel
                                            ('GHC.Maybe.Just "unTok")
                                            'GHC.Generics.NoSourceUnpackedness
                                            'GHC.Generics.NoSourceStrictness
                                            'GHC.Generics.DecidedLazy)
                                         (GHC.Generics.K1 GHC.Generics.R a)
                                       GHC.Generics.:*: GHC.Generics.M1
                                                          GHC.Generics.S
                                                          ('GHC.Generics.MetaSel
                                                             ('GHC.Maybe.Just "rowStart")
                                                             'GHC.Generics.NoSourceUnpackedness
                                                             'GHC.Generics.NoSourceStrictness
                                                             'GHC.Generics.DecidedLazy)
                                                          (GHC.Generics.K1
                                                             GHC.Generics.R LamFunLexer.Row))
                                      GHC.Generics.:*: (GHC.Generics.M1
                                                          GHC.Generics.S
                                                          ('GHC.Generics.MetaSel
                                                             ('GHC.Maybe.Just "rowEnd")
                                                             'GHC.Generics.NoSourceUnpackedness
                                                             'GHC.Generics.NoSourceStrictness
                                                             'GHC.Generics.DecidedLazy)
                                                          (GHC.Generics.K1
                                                             GHC.Generics.R LamFunLexer.Row)
                                                        GHC.Generics.:*: (GHC.Generics.M1
                                                                            GHC.Generics.S
                                                                            ('GHC.Generics.MetaSel
                                                                               ('GHC.Maybe.Just
                                                                                  "colStart")
                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                               'GHC.Generics.NoSourceStrictness
                                                                               'GHC.Generics.DecidedLazy)
                                                                            (GHC.Generics.K1
                                                                               GHC.Generics.R
                                                                               LamFunLexer.Col)
                                                                          GHC.Generics.:*: GHC.Generics.M1
                                                                                             GHC.Generics.S
                                                                                             ('GHC.Generics.MetaSel
                                                                                                ('GHC.Maybe.Just
                                                                                                   "colEnd")
                                                                                                'GHC.Generics.NoSourceUnpackedness
                                                                                                'GHC.Generics.NoSourceStrictness
                                                                                                'GHC.Generics.DecidedLazy)
                                                                                             (GHC.Generics.K1
                                                                                                GHC.Generics.R
                                                                                                LamFunLexer.Col))))>_R) ; Sub (Sym (LamFunLexer.Rep_Token[0]
                                                                                                                                        <a>_N))) <x1>_N)
                  (LamFunLexer.$fGenericToken_$cto @ a) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fGenericToken1 ::
    LamFunLexer.Token a
    -> GHC.Generics.M1
         GHC.Generics.C
         ('GHC.Generics.MetaCons
            "Token" 'GHC.Generics.PrefixI 'GHC.Types.True)
         ((GHC.Generics.M1
             GHC.Generics.S
             ('GHC.Generics.MetaSel
                ('GHC.Maybe.Just "unTok")
                'GHC.Generics.NoSourceUnpackedness
                'GHC.Generics.NoSourceStrictness
                'GHC.Generics.DecidedLazy)
             (GHC.Generics.K1 GHC.Generics.R a)
           GHC.Generics.:*: GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 ('GHC.Maybe.Just "rowStart")
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row))
          GHC.Generics.:*: (GHC.Generics.M1
                              GHC.Generics.S
                              ('GHC.Generics.MetaSel
                                 ('GHC.Maybe.Just "rowEnd")
                                 'GHC.Generics.NoSourceUnpackedness
                                 'GHC.Generics.NoSourceStrictness
                                 'GHC.Generics.DecidedLazy)
                              (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row)
                            GHC.Generics.:*: (GHC.Generics.M1
                                                GHC.Generics.S
                                                ('GHC.Generics.MetaSel
                                                   ('GHC.Maybe.Just "colStart")
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Col)
                                              GHC.Generics.:*: GHC.Generics.M1
                                                                 GHC.Generics.S
                                                                 ('GHC.Generics.MetaSel
                                                                    ('GHC.Maybe.Just "colEnd")
                                                                    'GHC.Generics.NoSourceUnpackedness
                                                                    'GHC.Generics.NoSourceStrictness
                                                                    'GHC.Generics.DecidedLazy)
                                                                 (GHC.Generics.K1
                                                                    GHC.Generics.R
                                                                    LamFunLexer.Col))))
         x
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ x1 (x2 :: LamFunLexer.Token a) ->
                 case x2 of wild { LamFunLexer.Token g1 g2 g3 g4 g5 ->
                 (GHC.Generics.:*:
                    @ *
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            ('GHC.Maybe.Just "unTok")
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.NoSourceStrictness
                            'GHC.Generics.DecidedLazy)
                         (GHC.Generics.K1 GHC.Generics.R a)
                       GHC.Generics.:*: GHC.Generics.M1
                                          GHC.Generics.S
                                          ('GHC.Generics.MetaSel
                                             ('GHC.Maybe.Just "rowStart")
                                             'GHC.Generics.NoSourceUnpackedness
                                             'GHC.Generics.NoSourceStrictness
                                             'GHC.Generics.DecidedLazy)
                                          (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row))
                    @ (GHC.Generics.M1
                         GHC.Generics.S
                         ('GHC.Generics.MetaSel
                            ('GHC.Maybe.Just "rowEnd")
                            'GHC.Generics.NoSourceUnpackedness
                            'GHC.Generics.NoSourceStrictness
                            'GHC.Generics.DecidedLazy)
                         (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row)
                       GHC.Generics.:*: (GHC.Generics.M1
                                           GHC.Generics.S
                                           ('GHC.Generics.MetaSel
                                              ('GHC.Maybe.Just "colStart")
                                              'GHC.Generics.NoSourceUnpackedness
                                              'GHC.Generics.NoSourceStrictness
                                              'GHC.Generics.DecidedLazy)
                                           (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Col)
                                         GHC.Generics.:*: GHC.Generics.M1
                                                            GHC.Generics.S
                                                            ('GHC.Generics.MetaSel
                                                               ('GHC.Maybe.Just "colEnd")
                                                               'GHC.Generics.NoSourceUnpackedness
                                                               'GHC.Generics.NoSourceStrictness
                                                               'GHC.Generics.DecidedLazy)
                                                            (GHC.Generics.K1
                                                               GHC.Generics.R LamFunLexer.Col)))
                    @ x1
                    (GHC.Generics.:*:
                       @ *
                       @ (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               ('GHC.Maybe.Just "unTok")
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.K1 GHC.Generics.R a))
                       @ (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               ('GHC.Maybe.Just "rowStart")
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row))
                       @ x1
                       g1
                         `cast`
                       (Sym (GHC.Generics.N:K1[0]
                                 <*>_N <GHC.Generics.R>_P <a>_R <x1>_P) ; Sym (GHC.Generics.N:M1[0]
                                                                                   <*>_N
                                                                                   <GHC.Generics.S>_P
                                                                                   <'GHC.Generics.MetaSel
                                                                                      ('GHC.Maybe.Just
                                                                                         "unTok")
                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                      'GHC.Generics.DecidedLazy>_P
                                                                                   <GHC.Generics.K1
                                                                                      GHC.Generics.R
                                                                                      a>_R) <x1>_N)
                       g2
                         `cast`
                       (Sym (GHC.Generics.N:K1[0]
                                 <*>_N
                                 <GHC.Generics.R>_P
                                 <LamFunLexer.Row>_R
                                 <x1>_P) ; Sym (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <GHC.Generics.S>_P
                                                    <'GHC.Generics.MetaSel
                                                       ('GHC.Maybe.Just "rowStart")
                                                       'GHC.Generics.NoSourceUnpackedness
                                                       'GHC.Generics.NoSourceStrictness
                                                       'GHC.Generics.DecidedLazy>_P
                                                    <GHC.Generics.K1
                                                       GHC.Generics.R LamFunLexer.Row>_R) <x1>_N))
                    (GHC.Generics.:*:
                       @ *
                       @ (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               ('GHC.Maybe.Just "rowEnd")
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row))
                       @ (GHC.Generics.M1
                            GHC.Generics.S
                            ('GHC.Generics.MetaSel
                               ('GHC.Maybe.Just "colStart")
                               'GHC.Generics.NoSourceUnpackedness
                               'GHC.Generics.NoSourceStrictness
                               'GHC.Generics.DecidedLazy)
                            (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Col)
                          GHC.Generics.:*: GHC.Generics.M1
                                             GHC.Generics.S
                                             ('GHC.Generics.MetaSel
                                                ('GHC.Maybe.Just "colEnd")
                                                'GHC.Generics.NoSourceUnpackedness
                                                'GHC.Generics.NoSourceStrictness
                                                'GHC.Generics.DecidedLazy)
                                             (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Col))
                       @ x1
                       g3
                         `cast`
                       (Sym (GHC.Generics.N:K1[0]
                                 <*>_N
                                 <GHC.Generics.R>_P
                                 <LamFunLexer.Row>_R
                                 <x1>_P) ; Sym (GHC.Generics.N:M1[0]
                                                    <*>_N
                                                    <GHC.Generics.S>_P
                                                    <'GHC.Generics.MetaSel
                                                       ('GHC.Maybe.Just "rowEnd")
                                                       'GHC.Generics.NoSourceUnpackedness
                                                       'GHC.Generics.NoSourceStrictness
                                                       'GHC.Generics.DecidedLazy>_P
                                                    <GHC.Generics.K1
                                                       GHC.Generics.R LamFunLexer.Row>_R) <x1>_N)
                       (GHC.Generics.:*:
                          @ *
                          @ (GHC.Generics.M1
                               GHC.Generics.S
                               ('GHC.Generics.MetaSel
                                  ('GHC.Maybe.Just "colStart")
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Col))
                          @ (GHC.Generics.M1
                               GHC.Generics.S
                               ('GHC.Generics.MetaSel
                                  ('GHC.Maybe.Just "colEnd")
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Col))
                          @ x1
                          g4
                            `cast`
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N
                                    <GHC.Generics.R>_P
                                    <LamFunLexer.Col>_R
                                    <x1>_P) ; Sym (GHC.Generics.N:M1[0]
                                                       <*>_N
                                                       <GHC.Generics.S>_P
                                                       <'GHC.Generics.MetaSel
                                                          ('GHC.Maybe.Just "colStart")
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy>_P
                                                       <GHC.Generics.K1
                                                          GHC.Generics.R LamFunLexer.Col>_R) <x1>_N)
                          g5
                            `cast`
                          (Sym (GHC.Generics.N:K1[0]
                                    <*>_N
                                    <GHC.Generics.R>_P
                                    <LamFunLexer.Col>_R
                                    <x1>_P) ; Sym (GHC.Generics.N:M1[0]
                                                       <*>_N
                                                       <GHC.Generics.S>_P
                                                       <'GHC.Generics.MetaSel
                                                          ('GHC.Maybe.Just "colEnd")
                                                          'GHC.Generics.NoSourceUnpackedness
                                                          'GHC.Generics.NoSourceStrictness
                                                          'GHC.Generics.DecidedLazy>_P
                                                       <GHC.Generics.K1
                                                          GHC.Generics.R
                                                          LamFunLexer.Col>_R) <x1>_N))))
                   `cast`
                 (Sym (GHC.Generics.N:M1[0]
                           <*>_N
                           <GHC.Generics.C>_P
                           <'GHC.Generics.MetaCons
                              "Token" 'GHC.Generics.PrefixI 'GHC.Types.True>_P
                           <(GHC.Generics.M1
                               GHC.Generics.S
                               ('GHC.Generics.MetaSel
                                  ('GHC.Maybe.Just "unTok")
                                  'GHC.Generics.NoSourceUnpackedness
                                  'GHC.Generics.NoSourceStrictness
                                  'GHC.Generics.DecidedLazy)
                               (GHC.Generics.K1 GHC.Generics.R a)
                             GHC.Generics.:*: GHC.Generics.M1
                                                GHC.Generics.S
                                                ('GHC.Generics.MetaSel
                                                   ('GHC.Maybe.Just "rowStart")
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row))
                            GHC.Generics.:*: (GHC.Generics.M1
                                                GHC.Generics.S
                                                ('GHC.Generics.MetaSel
                                                   ('GHC.Maybe.Just "rowEnd")
                                                   'GHC.Generics.NoSourceUnpackedness
                                                   'GHC.Generics.NoSourceStrictness
                                                   'GHC.Generics.DecidedLazy)
                                                (GHC.Generics.K1 GHC.Generics.R LamFunLexer.Row)
                                              GHC.Generics.:*: (GHC.Generics.M1
                                                                  GHC.Generics.S
                                                                  ('GHC.Generics.MetaSel
                                                                     ('GHC.Maybe.Just "colStart")
                                                                     'GHC.Generics.NoSourceUnpackedness
                                                                     'GHC.Generics.NoSourceStrictness
                                                                     'GHC.Generics.DecidedLazy)
                                                                  (GHC.Generics.K1
                                                                     GHC.Generics.R LamFunLexer.Col)
                                                                GHC.Generics.:*: GHC.Generics.M1
                                                                                   GHC.Generics.S
                                                                                   ('GHC.Generics.MetaSel
                                                                                      ('GHC.Maybe.Just
                                                                                         "colEnd")
                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                      'GHC.Generics.DecidedLazy)
                                                                                   (GHC.Generics.K1
                                                                                      GHC.Generics.R
                                                                                      LamFunLexer.Col)))>_R) <x1>_N) }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fGenericToken_$cto ::
    GHC.Generics.Rep (LamFunLexer.Token a) x -> LamFunLexer.Token a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SS(LS)),1*U(1*U(U,U),1*U(U,1*U(U,U)))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ x1 (ds :: GHC.Generics.Rep (LamFunLexer.Token a) x1) ->
                 case ds
                        `cast`
                      ((Sub (LamFunLexer.Rep_Token[0] <a>_N) ; (GHC.Generics.N:M1[0]
                                                                    <*>_N
                                                                    <GHC.Generics.D>_P
                                                                    <'GHC.Generics.MetaData
                                                                       "Token"
                                                                       "LamFunLexer"
                                                                       "LamFun-3.14.1-1NElG62CogO50XNaLIVWxW"
                                                                       'GHC.Types.False>_P
                                                                    <GHC.Generics.M1
                                                                       GHC.Generics.C
                                                                       ('GHC.Generics.MetaCons
                                                                          "Token"
                                                                          'GHC.Generics.PrefixI
                                                                          'GHC.Types.True)
                                                                       ((GHC.Generics.M1
                                                                           GHC.Generics.S
                                                                           ('GHC.Generics.MetaSel
                                                                              ('GHC.Maybe.Just
                                                                                 "unTok")
                                                                              'GHC.Generics.NoSourceUnpackedness
                                                                              'GHC.Generics.NoSourceStrictness
                                                                              'GHC.Generics.DecidedLazy)
                                                                           (GHC.Generics.K1
                                                                              GHC.Generics.R a)
                                                                         GHC.Generics.:*: GHC.Generics.M1
                                                                                            GHC.Generics.S
                                                                                            ('GHC.Generics.MetaSel
                                                                                               ('GHC.Maybe.Just
                                                                                                  "rowStart")
                                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                                               'GHC.Generics.NoSourceStrictness
                                                                                               'GHC.Generics.DecidedLazy)
                                                                                            (GHC.Generics.K1
                                                                                               GHC.Generics.R
                                                                                               LamFunLexer.Row))
                                                                        GHC.Generics.:*: (GHC.Generics.M1
                                                                                            GHC.Generics.S
                                                                                            ('GHC.Generics.MetaSel
                                                                                               ('GHC.Maybe.Just
                                                                                                  "rowEnd")
                                                                                               'GHC.Generics.NoSourceUnpackedness
                                                                                               'GHC.Generics.NoSourceStrictness
                                                                                               'GHC.Generics.DecidedLazy)
                                                                                            (GHC.Generics.K1
                                                                                               GHC.Generics.R
                                                                                               LamFunLexer.Row)
                                                                                          GHC.Generics.:*: (GHC.Generics.M1
                                                                                                              GHC.Generics.S
                                                                                                              ('GHC.Generics.MetaSel
                                                                                                                 ('GHC.Maybe.Just
                                                                                                                    "colStart")
                                                                                                                 'GHC.Generics.NoSourceUnpackedness
                                                                                                                 'GHC.Generics.NoSourceStrictness
                                                                                                                 'GHC.Generics.DecidedLazy)
                                                                                                              (GHC.Generics.K1
                                                                                                                 GHC.Generics.R
                                                                                                                 LamFunLexer.Col)
                                                                                                            GHC.Generics.:*: GHC.Generics.M1
                                                                                                                               GHC.Generics.S
                                                                                                                               ('GHC.Generics.MetaSel
                                                                                                                                  ('GHC.Maybe.Just
                                                                                                                                     "colEnd")
                                                                                                                                  'GHC.Generics.NoSourceUnpackedness
                                                                                                                                  'GHC.Generics.NoSourceStrictness
                                                                                                                                  'GHC.Generics.DecidedLazy)
                                                                                                                               (GHC.Generics.K1
                                                                                                                                  GHC.Generics.R
                                                                                                                                  LamFunLexer.Col))))>_R ; GHC.Generics.N:M1[0]
                                                                                                                                                               <*>_N
                                                                                                                                                               <GHC.Generics.C>_P
                                                                                                                                                               <'GHC.Generics.MetaCons
                                                                                                                                                                  "Token"
                                                                                                                                                                  'GHC.Generics.PrefixI
                                                                                                                                                                  'GHC.Types.True>_P
                                                                                                                                                               <(GHC.Generics.M1
                                                                                                                                                                   GHC.Generics.S
                                                                                                                                                                   ('GHC.Generics.MetaSel
                                                                                                                                                                      ('GHC.Maybe.Just
                                                                                                                                                                         "unTok")
                                                                                                                                                                      'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                                      'GHC.Generics.NoSourceStrictness
                                                                                                                                                                      'GHC.Generics.DecidedLazy)
                                                                                                                                                                   (GHC.Generics.K1
                                                                                                                                                                      GHC.Generics.R
                                                                                                                                                                      a)
                                                                                                                                                                 GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                                                                    GHC.Generics.S
                                                                                                                                                                                    ('GHC.Generics.MetaSel
                                                                                                                                                                                       ('GHC.Maybe.Just
                                                                                                                                                                                          "rowStart")
                                                                                                                                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                                                       'GHC.Generics.NoSourceStrictness
                                                                                                                                                                                       'GHC.Generics.DecidedLazy)
                                                                                                                                                                                    (GHC.Generics.K1
                                                                                                                                                                                       GHC.Generics.R
                                                                                                                                                                                       LamFunLexer.Row))
                                                                                                                                                                GHC.Generics.:*: (GHC.Generics.M1
                                                                                                                                                                                    GHC.Generics.S
                                                                                                                                                                                    ('GHC.Generics.MetaSel
                                                                                                                                                                                       ('GHC.Maybe.Just
                                                                                                                                                                                          "rowEnd")
                                                                                                                                                                                       'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                                                       'GHC.Generics.NoSourceStrictness
                                                                                                                                                                                       'GHC.Generics.DecidedLazy)
                                                                                                                                                                                    (GHC.Generics.K1
                                                                                                                                                                                       GHC.Generics.R
                                                                                                                                                                                       LamFunLexer.Row)
                                                                                                                                                                                  GHC.Generics.:*: (GHC.Generics.M1
                                                                                                                                                                                                      GHC.Generics.S
                                                                                                                                                                                                      ('GHC.Generics.MetaSel
                                                                                                                                                                                                         ('GHC.Maybe.Just
                                                                                                                                                                                                            "colStart")
                                                                                                                                                                                                         'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                                                                         'GHC.Generics.NoSourceStrictness
                                                                                                                                                                                                         'GHC.Generics.DecidedLazy)
                                                                                                                                                                                                      (GHC.Generics.K1
                                                                                                                                                                                                         GHC.Generics.R
                                                                                                                                                                                                         LamFunLexer.Col)
                                                                                                                                                                                                    GHC.Generics.:*: GHC.Generics.M1
                                                                                                                                                                                                                       GHC.Generics.S
                                                                                                                                                                                                                       ('GHC.Generics.MetaSel
                                                                                                                                                                                                                          ('GHC.Maybe.Just
                                                                                                                                                                                                                             "colEnd")
                                                                                                                                                                                                                          'GHC.Generics.NoSourceUnpackedness
                                                                                                                                                                                                                          'GHC.Generics.NoSourceStrictness
                                                                                                                                                                                                                          'GHC.Generics.DecidedLazy)
                                                                                                                                                                                                                       (GHC.Generics.K1
                                                                                                                                                                                                                          GHC.Generics.R
                                                                                                                                                                                                                          LamFunLexer.Col)))>_R)) <x1>_N) of wild { GHC.Generics.:*: ds1 ds2 ->
                 case ds1 of wild1 { GHC.Generics.:*: ds3 ds4 ->
                 case ds2 of wild2 { GHC.Generics.:*: ds5 ds6 ->
                 case ds6 of wild3 { GHC.Generics.:*: ds7 ds8 ->
                 LamFunLexer.Token
                   @ a
                   ds3
                     `cast`
                   (GHC.Generics.N:M1[0]
                        <*>_N
                        <GHC.Generics.S>_P
                        <'GHC.Generics.MetaSel
                           ('GHC.Maybe.Just "unTok")
                           'GHC.Generics.NoSourceUnpackedness
                           'GHC.Generics.NoSourceStrictness
                           'GHC.Generics.DecidedLazy>_P
                        <GHC.Generics.K1 GHC.Generics.R a>_R <x1>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <a>_R
                                                                          <x1>_P)
                   ds4
                     `cast`
                   (GHC.Generics.N:M1[0]
                        <*>_N
                        <GHC.Generics.S>_P
                        <'GHC.Generics.MetaSel
                           ('GHC.Maybe.Just "rowStart")
                           'GHC.Generics.NoSourceUnpackedness
                           'GHC.Generics.NoSourceStrictness
                           'GHC.Generics.DecidedLazy>_P
                        <GHC.Generics.K1
                           GHC.Generics.R LamFunLexer.Row>_R <x1>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <LamFunLexer.Row>_R
                                                                          <x1>_P)
                   ds5
                     `cast`
                   (GHC.Generics.N:M1[0]
                        <*>_N
                        <GHC.Generics.S>_P
                        <'GHC.Generics.MetaSel
                           ('GHC.Maybe.Just "rowEnd")
                           'GHC.Generics.NoSourceUnpackedness
                           'GHC.Generics.NoSourceStrictness
                           'GHC.Generics.DecidedLazy>_P
                        <GHC.Generics.K1
                           GHC.Generics.R LamFunLexer.Row>_R <x1>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <LamFunLexer.Row>_R
                                                                          <x1>_P)
                   ds7
                     `cast`
                   (GHC.Generics.N:M1[0]
                        <*>_N
                        <GHC.Generics.S>_P
                        <'GHC.Generics.MetaSel
                           ('GHC.Maybe.Just "colStart")
                           'GHC.Generics.NoSourceUnpackedness
                           'GHC.Generics.NoSourceStrictness
                           'GHC.Generics.DecidedLazy>_P
                        <GHC.Generics.K1
                           GHC.Generics.R LamFunLexer.Col>_R <x1>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <LamFunLexer.Col>_R
                                                                          <x1>_P)
                   ds8
                     `cast`
                   (GHC.Generics.N:M1[0]
                        <*>_N
                        <GHC.Generics.S>_P
                        <'GHC.Generics.MetaSel
                           ('GHC.Maybe.Just "colEnd")
                           'GHC.Generics.NoSourceUnpackedness
                           'GHC.Generics.NoSourceStrictness
                           'GHC.Generics.DecidedLazy>_P
                        <GHC.Generics.K1
                           GHC.Generics.R LamFunLexer.Col>_R <x1>_N ; GHC.Generics.N:K1[0]
                                                                          <*>_N
                                                                          <GHC.Generics.R>_P
                                                                          <LamFunLexer.Col>_R
                                                                          <x1>_P) } } } }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fHashableCol :: Data.Hashable.Class.Hashable LamFunLexer.Col
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Col
                  Data.Hashable.Class.$fHashableInt_$chashWithSalt
                    `cast`
                  (<GHC.Types.Int>_R
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R <GHC.Types.Int>_R)
                  (GHC.Base.id @ GHC.Types.Int)
                    `cast`
                  (Sym (LamFunLexer.N:Col[0]) ->_R <GHC.Types.Int>_R) -}
332c1546bd09260727a773e99e195081
  $fHashableRow :: Data.Hashable.Class.Hashable LamFunLexer.Row
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Row
                  Data.Hashable.Class.$fHashableInt_$chashWithSalt
                    `cast`
                  (<GHC.Types.Int>_R
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R <GHC.Types.Int>_R)
                  (GHC.Base.id @ GHC.Types.Int)
                    `cast`
                  (Sym (LamFunLexer.N:Row[0]) ->_R <GHC.Types.Int>_R) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fHashableToken ::
    Data.Hashable.Class.Hashable a =>
    Data.Hashable.Class.Hashable (LamFunLexer.Token a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U(U))),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: Data.Hashable.Class.Hashable a).
                  @ (LamFunLexer.Token a)
                  (LamFunLexer.$fHashableToken_$chashWithSalt @ a v)
                  (LamFunLexer.$fHashableToken_$chash @ a v) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fHashableToken_$chash ::
    Data.Hashable.Class.Hashable a =>
    LamFunLexer.Token a -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(C(C(S(S)))L),1*U(1*C1(C1(U(U))),A)><S(LS(S)S(S)S(S)S(S)),1*U(U,1*U(U),1*U(U),1*U(U),1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dHashable :: Data.Hashable.Class.Hashable a) ->
                 LamFunLexer.$fHashableToken_$chashWithSalt
                   @ a
                   $dHashable
                   Data.Hashable.Class.defaultSalt) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fHashableToken_$chashWithSalt ::
    Data.Hashable.Class.Hashable a =>
    GHC.Types.Int -> LamFunLexer.Token a -> GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S(S)))L),1*U(1*C1(C1(U(U))),A)><L,U><S(LS(S)S(S)S(S)S(S)),1*U(U,1*U(U),1*U(U),1*U(U),1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Data.Hashable.Class.Hashable a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: LamFunLexer.Token a) ->
                 case w of ww { Data.Hashable.Class.C:Hashable ww1 ww2 ->
                 case w2 of ww3 { LamFunLexer.Token ww4 ww5 ww6 ww7 ww8 ->
                 case ww5
                        `cast`
                      (LamFunLexer.N:Row[0]) of ww9 { GHC.Types.I# ww10 ->
                 case ww6
                        `cast`
                      (LamFunLexer.N:Row[0]) of ww11 { GHC.Types.I# ww12 ->
                 case ww7
                        `cast`
                      (LamFunLexer.N:Col[0]) of ww13 { GHC.Types.I# ww14 ->
                 case ww8
                        `cast`
                      (LamFunLexer.N:Col[0]) of ww15 { GHC.Types.I# ww16 ->
                 case ww1 w1 ww4 of wild { GHC.Types.I# x1 ->
                 GHC.Types.I#
                   (GHC.Prim.xorI#
                      (GHC.Prim.*#
                         (GHC.Prim.xorI#
                            (GHC.Prim.*#
                               (GHC.Prim.xorI#
                                  (GHC.Prim.*#
                                     (GHC.Prim.xorI# (GHC.Prim.*# x1 16777619#) ww10)
                                     16777619#)
                                  ww12)
                               16777619#)
                            ww14)
                         16777619#)
                      ww16) } } } } } } }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fIsStringToken ::
    Data.String.IsString a =>
    Data.String.IsString (LamFunLexer.Token a)
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>m,
     Inline: (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                LamFunLexer.$fIsStringToken_$cfromString
                  `cast`
                (forall (a :: <*>_N).
                 <Data.String.IsString a>_R
                 ->_R Sym (Data.String.N:IsString[0]) <LamFunLexer.Token a>_N) -}
6d3e21139ecc6a1460134fdca286728c
  $fIsStringToken1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fIsStringToken_$cfromString ::
    Data.String.IsString a => GHC.Base.String -> LamFunLexer.Token a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dIsString :: Data.String.IsString a)
                   (s :: GHC.Base.String) ->
                 LamFunLexer.Token
                   @ a
                   ($dIsString `cast` (Data.String.N:IsString[0] <a>_N) s)
                   LamFunLexer.$fIsStringToken1 `cast` (Sym (LamFunLexer.N:Row[0]))
                   LamFunLexer.$fIsStringToken1 `cast` (Sym (LamFunLexer.N:Row[0]))
                   LamFunLexer.$fIsStringToken1 `cast` (Sym (LamFunLexer.N:Col[0]))
                   LamFunLexer.$fIsStringToken1
                     `cast`
                   (Sym (LamFunLexer.N:Col[0]))) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fNumCol :: GHC.Num.Num LamFunLexer.Col
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Col
                  GHC.Num.$fNumInt_$c+
                    `cast`
                  (Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0]))
                  GHC.Num.$fNumInt_$c-
                    `cast`
                  (Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0]))
                  GHC.Num.$fNumInt_$c*
                    `cast`
                  (Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R Sym (LamFunLexer.N:Col[0]))
                  GHC.Num.$fNumInt_$cnegate
                    `cast`
                  (Sym (LamFunLexer.N:Col[0]) ->_R Sym (LamFunLexer.N:Col[0]))
                  GHC.Num.$fNumInt_$cabs
                    `cast`
                  (Sym (LamFunLexer.N:Col[0]) ->_R Sym (LamFunLexer.N:Col[0]))
                  GHC.Num.$fNumInt_$csignum
                    `cast`
                  (Sym (LamFunLexer.N:Col[0]) ->_R Sym (LamFunLexer.N:Col[0]))
                  GHC.Num.$fNumInt_$cfromInteger
                    `cast`
                  (<GHC.Integer.Type.Integer>_R ->_R Sym (LamFunLexer.N:Col[0])) -}
332c1546bd09260727a773e99e195081
  $fNumRow :: GHC.Num.Num LamFunLexer.Row
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Row
                  GHC.Num.$fNumInt_$c+
                    `cast`
                  (Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0]))
                  GHC.Num.$fNumInt_$c-
                    `cast`
                  (Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0]))
                  GHC.Num.$fNumInt_$c*
                    `cast`
                  (Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R Sym (LamFunLexer.N:Row[0]))
                  GHC.Num.$fNumInt_$cnegate
                    `cast`
                  (Sym (LamFunLexer.N:Row[0]) ->_R Sym (LamFunLexer.N:Row[0]))
                  GHC.Num.$fNumInt_$cabs
                    `cast`
                  (Sym (LamFunLexer.N:Row[0]) ->_R Sym (LamFunLexer.N:Row[0]))
                  GHC.Num.$fNumInt_$csignum
                    `cast`
                  (Sym (LamFunLexer.N:Row[0]) ->_R Sym (LamFunLexer.N:Row[0]))
                  GHC.Num.$fNumInt_$cfromInteger
                    `cast`
                  (<GHC.Integer.Type.Integer>_R ->_R Sym (LamFunLexer.N:Row[0])) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken ::
    GHC.Classes.Ord a => GHC.Classes.Ord (LamFunLexer.Token a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(1*U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Classes.Ord a).
                  @ (LamFunLexer.Token a)
                  (LamFunLexer.$fOrdToken_$cp1Ord @ a v)
                  (LamFunLexer.$fOrdToken_$ccompare @ a v)
                  (LamFunLexer.$fOrdToken_$c< @ a v)
                  (LamFunLexer.$fOrdToken_$c<= @ a v)
                  (LamFunLexer.$fOrdToken_$c> @ a v)
                  (LamFunLexer.$fOrdToken_$c>= @ a v)
                  (LamFunLexer.$fOrdToken_$cmax @ a v)
                  (LamFunLexer.$fOrdToken_$cmin @ a v) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$c< ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.compare
                        @ a
                        $dOrd
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$c<= ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.compare
                        @ a
                        $dOrd
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$c> ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.compare
                        @ a
                        $dOrd
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$c>= ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.compare
                        @ a
                        $dOrd
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$ccompare ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,1*U(1*U,A,A,A,A)><L,1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (t1 :: LamFunLexer.Token a)
                   (t2 :: LamFunLexer.Token a) ->
                 GHC.Classes.compare
                   @ a
                   $dOrd
                   (case t1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                   (case t2 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                    ds })) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$cmax ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> LamFunLexer.Token a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U(U,U,U,U,U)><L,U(U,U,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.compare
                        @ a
                        $dOrd
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   DEFAULT -> y GHC.Types.GT -> x1 }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$cmin ::
    GHC.Classes.Ord a =>
    LamFunLexer.Token a -> LamFunLexer.Token a -> LamFunLexer.Token a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLLLLL),1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U(U,U,U,U,U)><L,U(U,U,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (x1 :: LamFunLexer.Token a)
                   (y :: LamFunLexer.Token a) ->
                 case GHC.Classes.compare
                        @ a
                        $dOrd
                        (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 -> ds })
                        (case y of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                         ds }) of wild {
                   DEFAULT -> x1 GHC.Types.GT -> y }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fOrdToken_$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (LamFunLexer.Token a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dOrd :: GHC.Classes.Ord a) ->
                 LamFunLexer.$fEqToken @ a (GHC.Classes.$p1Ord @ a $dOrd)) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fShowCol :: GHC.Show.Show LamFunLexer.Col
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Col
                  GHC.Show.showSignedInt
                    `cast`
                  (<GHC.Types.Int>_R
                   ->_R Sym (LamFunLexer.N:Col[0])
                   ->_R <[GHC.Types.Char] -> [GHC.Types.Char]>_R)
                  GHC.Show.$fShowInt_$cshow
                    `cast`
                  (Sym (LamFunLexer.N:Col[0]) ->_R <[GHC.Types.Char]>_R)
                  GHC.Show.$fShowInt_$cshowList
                    `cast`
                  (([Sym (LamFunLexer.N:Col[0])])_R
                   ->_R <[GHC.Types.Char] -> [GHC.Types.Char]>_R) -}
8f2332b352b177c2329324164108499b
  $fShowDropOrKeep ::
    GHC.Show.Show a => GHC.Show.Show (LamFunLexer.DropOrKeep a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (LamFunLexer.DropOrKeep a)
                  (LamFunLexer.$fShowDropOrKeep_$cshowsPrec @ a v)
                  (LamFunLexer.$fShowDropOrKeep_$cshow @ a v)
                  (LamFunLexer.$fShowDropOrKeep_$cshowList @ a v) -}
88905a7cacb4790623fe64e64b31b1bb
  $fShowDropOrKeep1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
bc63f5ed5bffa9013a768962a722e883
  $fShowDropOrKeep10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Drop"#) -}
d885644fb0891e9acc7f7c7da32372ef
  $fShowDropOrKeep2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("content = "#) -}
84b160c3e72bd76af14e646302028c63
  $fShowDropOrKeep3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("label = "#) -}
c2443e9b79c33d73ca7f0376c838fe32
  $fShowDropOrKeep4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DropOrKeep {"#) -}
ab668446af169d054602fef1568b326b
  $fShowDropOrKeep5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunLexer.$fShowDropOrKeep6) -}
b5b72f82b00c4f36e641c1f966f80aaf
  $fShowDropOrKeep6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("New"#) -}
60a20f52146b67432491e4ea0855583f
  $fShowDropOrKeep7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunLexer.$fShowDropOrKeep8) -}
ab9896e9c3ce4d270b85c8e25fab3a01
  $fShowDropOrKeep8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Keep"#) -}
d4b97d1560603122eee079c330b1f187
  $fShowDropOrKeep9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunLexer.$fShowDropOrKeep10) -}
73f02fd9088bf7097a9de5a2df4483d2
  $fShowDropOrKeepLabel :: GHC.Show.Show LamFunLexer.DropOrKeepLabel
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.DropOrKeepLabel
                  LamFunLexer.$fShowDropOrKeepLabel_$cshowsPrec
                  LamFunLexer.$fShowDropOrKeepLabel_$cshow
                  LamFunLexer.$fShowDropOrKeepLabel_$cshowList -}
73f02fd9088bf7097a9de5a2df4483d2
  $fShowDropOrKeepLabel_$cshow ::
    LamFunLexer.DropOrKeepLabel -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: LamFunLexer.DropOrKeepLabel) ->
                 case x1 of wild {
                   LamFunLexer.Drop -> LamFunLexer.$fShowDropOrKeep9
                   LamFunLexer.Keep -> LamFunLexer.$fShowDropOrKeep7
                   LamFunLexer.New -> LamFunLexer.$fShowDropOrKeep5 }) -}
73f02fd9088bf7097a9de5a2df4483d2
  $fShowDropOrKeepLabel_$cshowList ::
    [LamFunLexer.DropOrKeepLabel] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [LamFunLexer.DropOrKeepLabel]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ LamFunLexer.DropOrKeepLabel
                   LamFunLexer.$w$cshowsPrec1
                   ls
                   s) -}
73f02fd9088bf7097a9de5a2df4483d2
  $fShowDropOrKeepLabel_$cshowsPrec ::
    GHC.Types.Int -> LamFunLexer.DropOrKeepLabel -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: LamFunLexer.DropOrKeepLabel)
                   (w2 :: GHC.Base.String) ->
                 LamFunLexer.$w$cshowsPrec1 w1 w2) -}
8f2332b352b177c2329324164108499b
  $fShowDropOrKeep_$cshow ::
    GHC.Show.Show a => LamFunLexer.DropOrKeep a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x1 :: LamFunLexer.DropOrKeep a) ->
                 LamFunLexer.$fShowDropOrKeep_$cshowsPrec
                   @ a
                   $dShow
                   LamFunLexer.$fIsStringToken1
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8f2332b352b177c2329324164108499b
  $fShowDropOrKeep_$cshowList ::
    GHC.Show.Show a => [LamFunLexer.DropOrKeep a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [LamFunLexer.DropOrKeep a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LamFunLexer.DropOrKeep a)
                   (LamFunLexer.$fShowDropOrKeep_$cshowsPrec
                      @ a
                      $dShow
                      LamFunLexer.$fIsStringToken1)
                   ls
                   s) -}
8f2332b352b177c2329324164108499b
  $fShowDropOrKeep_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> LamFunLexer.DropOrKeep a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: LamFunLexer.DropOrKeep a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { LamFunLexer.DropOrKeep ww3 ww4 ->
                 LamFunLexer.$w$cshowsPrec @ a w ww1 ww3 ww4 } }) -}
332c1546bd09260727a773e99e195081
  $fShowRow :: GHC.Show.Show LamFunLexer.Row
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunLexer.Row
                  GHC.Show.showSignedInt
                    `cast`
                  (<GHC.Types.Int>_R
                   ->_R Sym (LamFunLexer.N:Row[0])
                   ->_R <[GHC.Types.Char] -> [GHC.Types.Char]>_R)
                  GHC.Show.$fShowInt_$cshow
                    `cast`
                  (Sym (LamFunLexer.N:Row[0]) ->_R <[GHC.Types.Char]>_R)
                  GHC.Show.$fShowInt_$cshowList
                    `cast`
                  (([Sym (LamFunLexer.N:Row[0])])_R
                   ->_R <[GHC.Types.Char] -> [GHC.Types.Char]>_R) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fShowToken ::
    GHC.Show.Show a => GHC.Show.Show (LamFunLexer.Token a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(U),A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (LamFunLexer.Token a)
                  (LamFunLexer.$fShowToken_$cshowsPrec @ a v)
                  (LamFunLexer.$fShowToken_$cshow @ a v)
                  (LamFunLexer.$fShowToken_$cshowList @ a v) -}
502e06befe4ea8aaf3482cc4714662bc
  $fShowToken1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunLexer.$fShowToken2) -}
59fd58ddd9ff4c287bcb4c557d9a133f
  $fShowToken2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (")"#) -}
e80513779b13d5348f917de0e483ece8
  $fShowToken3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("), Col ("#) -}
0c69665c52a8cfe606b702b36d54a7a2
  $fShowToken4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
4f24975175eda1dfda26e9d8c4ad8c36
  $fShowToken5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" : Row ("#) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fShowToken_$cshow ::
    GHC.Show.Show a => LamFunLexer.Token a -> GHC.Base.String
  {- Arity: 2,
     Strictness: <S(LC(S)L),1*U(A,1*C1(U),A)><S(LS(S)LLL),1*U(U,1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: LamFunLexer.Token a) ->
                 case w of ww { GHC.Show.C:Show ww1 ww2 ww3 ->
                 case w1 of ww4 { LamFunLexer.Token ww5 ww6 ww7 ww8 ww9 ->
                 case ww6
                        `cast`
                      (LamFunLexer.N:Row[0]) of ww10 { GHC.Types.I# ww11 ->
                 LamFunLexer.$w$cshow @ a ww2 ww5 ww11 ww7 ww8 ww9 } } }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fShowToken_$cshowList ::
    GHC.Show.Show a => [LamFunLexer.Token a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [LamFunLexer.Token a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LamFunLexer.Token a)
                   (\ (x1 :: LamFunLexer.Token a) (s1 :: GHC.Base.String)[OneShot] ->
                    case $dShow of ww { GHC.Show.C:Show ww1 ww2 ww3 ->
                    case x1 of ww4 { LamFunLexer.Token ww5 ww6 ww7 ww8 ww9 ->
                    case ww6
                           `cast`
                         (LamFunLexer.N:Row[0]) of ww10 { GHC.Types.I# ww11 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (LamFunLexer.$w$cshow @ a ww2 ww5 ww11 ww7 ww8 ww9)
                      s1 } } })
                   ls
                   s) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fShowToken_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> LamFunLexer.Token a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <S(LC(S)L),1*U(A,1*C1(U),A)><L,A><S(LS(S)LLL),1*U(U,1*U(1*U),1*U(1*U),1*U(1*U),1*U(1*U))><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds :: GHC.Types.Int)
                   (x1 :: LamFunLexer.Token a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (LamFunLexer.$fShowToken_$cshow @ a $dShow x1))
                   s) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fStringConvTokenb ::
    Data.String.Conv.StringConv a b =>
    Data.String.Conv.StringConv (LamFunLexer.Token a) b
  DFunId
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(C(U))><L,U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (1, False, True)
                LamFunLexer.$fStringConvTokenb_$cstrConv
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Data.String.Conv.StringConv a b>_R
                 ->_R Sym (Data.String.Conv.N:StringConv[0]
                               <LamFunLexer.Token a>_N <b>_N)) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $fStringConvTokenb_$cstrConv ::
    Data.String.Conv.StringConv a b =>
    Data.String.Conv.Leniency -> LamFunLexer.Token a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(C(U))><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   ($dStringConv :: Data.String.Conv.StringConv a b)
                   (l :: Data.String.Conv.Leniency) ->
                 let {
                   f :: a -> b
                   = $dStringConv
                       `cast`
                     (Data.String.Conv.N:StringConv[0] <a>_N <b>_N)
                       l
                 } in
                 \ (x1 :: LamFunLexer.Token a) ->
                 f (case x1 of wild { LamFunLexer.Token ds ds1 ds2 ds3 ds4 ->
                    ds })) -}
56ded2772ca08e11e06314573f905361
  $tc'Col :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1928137136108039669##
                   11449517097023543805##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'Col2
                   0#
                   LamFunLexer.$tc'Col1) -}
26025fce23f7a9f8300c2dec73130905
  $tc'Col1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
145c4f86bdaffe44f5d84690cc92044e
  $tc'Col2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'Col3) -}
593b025d4345d484cef8996279b6857e
  $tc'Col3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Col"#) -}
67d4e7b23a4f52a10b9ec65ab152bd60
  $tc'Drop :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8715635718158505634##
                   2332247194240271726##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'Drop2
                   0#
                   LamFunLexer.$tc'Drop1) -}
8b3cdf6a2b8d2e68ed20e4612e2a1f7d
  $tc'Drop1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
da41cee5176a198fa96c813f28e80956
  $tc'Drop2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'Drop3) -}
8d60ebeb14b9c19d8cb277207abdc560
  $tc'Drop3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Drop"#) -}
614e2873bca4c428bb4eca742c2e9be4
  $tc'DropOrKeep :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5675275469036488819##
                   12539851415589917791##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'DropOrKeep2
                   1#
                   LamFunLexer.$tc'DropOrKeep1) -}
aef6013090b84bd2f0e11f5905c9b7ea
  $tc'DropOrKeep1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
855e5be20214238c7221d9fb4bdddaf2
  $tc'DropOrKeep2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'DropOrKeep3) -}
1e3b9a13fe75c5de15f98658c07f1999
  $tc'DropOrKeep3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'DropOrKeep"#) -}
809f6b54ff2e98a3f4a00e022b2288bd
  $tc'Keep :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12357736508123934375##
                   14368219628273090424##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'Keep1
                   0#
                   LamFunLexer.$tc'Drop1) -}
c49ee9cd3c6c7b2893add1accde0a68d
  $tc'Keep1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'Keep2) -}
28d9639dff7397514566687a58e42605
  $tc'Keep2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Keep"#) -}
7bcb4a06af65e27c90c8af53764821ef
  $tc'New :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7901257106974887478##
                   8246720906730067040##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'New1
                   0#
                   LamFunLexer.$tc'Drop1) -}
73cafb2e949cfc4fcd780b6abc5fa9e3
  $tc'New1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'New2) -}
bd05ab28c96ac3da62e73743fde95f66
  $tc'New2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'New"#) -}
2f874134a0fa5956421ac5c715444c0b
  $tc'Row :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14323447574381934935##
                   4250622649873369198##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'Row2
                   0#
                   LamFunLexer.$tc'Row1) -}
4358c203b845df484e8295aae71c3f7d
  $tc'Row1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
def26e16c2318df49e6f90e09a8272c6
  $tc'Row2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'Row3) -}
015121e820918dfe589ee88a016459db
  $tc'Row3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Row"#) -}
6a0347cb1a8f54926747a8ceaae60981
  $tc'Token :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17163411562245698085##
                   8263572164501746814##
                   LamFunLexer.$trModule
                   LamFunLexer.$tc'Token2
                   1#
                   LamFunLexer.$tc'Token1) -}
697269fe29c13598078e88e96e318a2e
  $tc'Token1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
fe933dc459675d6363a1eeeb754af422
  $tc'Token2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tc'Token3) -}
dca3fa5bf584727753c130f7316725c7
  $tc'Token3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Token"#) -}
036ff463c6a7c1f37ef3d743b0ea06ce
  $tcCol :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7783651661877304084##
                   12147985784465203179##
                   LamFunLexer.$trModule
                   LamFunLexer.$tcCol1
                   0#
                   GHC.Types.krep$*) -}
a091cc29a05b33d8652e108c68f8ec35
  $tcCol1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tcCol2) -}
735bdefaf4764359254bdf04585cee2f
  $tcCol2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Col"#) -}
ea7e67fad72a9887f7f17c9f392214d6
  $tcDropOrKeep :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9076382273034777398##
                   13667445012902907726##
                   LamFunLexer.$trModule
                   LamFunLexer.$tcDropOrKeep1
                   0#
                   GHC.Types.krep$*Arr*) -}
72a3ab4d83b28d25a5389c8cac084974
  $tcDropOrKeep1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tcDropOrKeep2) -}
bc661cdca1ce242a77f4e18b9bcd2384
  $tcDropOrKeep2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DropOrKeep"#) -}
3e3018a59fb711f1f08eeb37d1743be5
  $tcDropOrKeepLabel :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7911960389471799538##
                   4239527367234719836##
                   LamFunLexer.$trModule
                   LamFunLexer.$tcDropOrKeepLabel1
                   0#
                   GHC.Types.krep$*) -}
191d095594dd651fb552c9de64ee5116
  $tcDropOrKeepLabel1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tcDropOrKeepLabel2) -}
b43e51a1961633bfc4712023419baf44
  $tcDropOrKeepLabel2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("DropOrKeepLabel"#) -}
9af3ee107d5413583b060880fee5b5c5
  $tcRow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17577318478994158265##
                   16061563941001381322##
                   LamFunLexer.$trModule
                   LamFunLexer.$tcRow1
                   0#
                   GHC.Types.krep$*) -}
310824578e922851e7c0fb9bbf5fabfc
  $tcRow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tcRow2) -}
537ed522aa195df26b4731a88b86e102
  $tcRow2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Row"#) -}
3ad85d7c18143cffaa2dbc8ee0edfc5a
  $tcToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14228306245863539463##
                   13066499958149293066##
                   LamFunLexer.$trModule
                   LamFunLexer.$tcToken1
                   0#
                   GHC.Types.krep$*Arr*) -}
6efae0c1114fc8e18cc56306a9464c30
  $tcToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$tcToken2) -}
caa5b9f55f60e8de7088753b5a82bf10
  $tcToken2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Token"#) -}
6442fb2fb78edd0eda4087aeccce9af3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   LamFunLexer.$trModule3
                   LamFunLexer.$trModule1) -}
7c931964b31e79d562cd19fbb6ca4d33
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$trModule2) -}
7eba26f25d8b213f661d6cbbc852bc8c
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamFunLexer"#) -}
02738d7a5d151f971cb39169b96b9367
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunLexer.$trModule4) -}
2e0c8f6d6f88ae381516a0566f259909
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("LamFun-3.14.1-1NElG62CogO50XNaLIVWxW"#) -}
f2c5a98949fb07f270f36c9e0675ac4d
  $w$cshow ::
    (a -> GHC.Base.String)
    -> a
    -> GHC.Prim.Int#
    -> LamFunLexer.Row
    -> LamFunLexer.Col
    -> LamFunLexer.Col
    -> GHC.Base.String
  {- Arity: 6,
     Strictness: <C(S),1*C1(U)><L,U><S,1*U><L,1*U(1*U)><L,1*U(1*U)><L,1*U(1*U)>,
     Inline: [2],
     Unfolding: (\ @ a
                   (ww :: a -> GHC.Base.String)
                   (ww1 :: a)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: LamFunLexer.Row)
                   (ww4 :: LamFunLexer.Col)
                   (ww5 :: LamFunLexer.Col) ->
                 case ww2 of wild {
                   DEFAULT
                   -> case ww3
                             `cast`
                           (LamFunLexer.N:Row[0]) of wild1 { GHC.Types.I# x1 ->
                      case x1 of wild2 {
                        DEFAULT
                        -> case ww4
                                  `cast`
                                (LamFunLexer.N:Col[0]) of wild3 { GHC.Types.I# x2 ->
                           case x2 of wild4 {
                             DEFAULT
                             -> case ww5
                                       `cast`
                                     (LamFunLexer.N:Col[0]) of wild5 { GHC.Types.I# x3 ->
                                case x3 of wild6 {
                                  DEFAULT
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       (ww ww1)
                                       (GHC.CString.unpackAppendCString#
                                          LamFunLexer.$fShowToken5
                                          (case GHC.Show.$wshowSignedInt
                                                  0#
                                                  wild
                                                  (GHC.Types.[]
                                                     @ GHC.Types.Char) of ww6 { (#,#) ww7 ww8 ->
                                           GHC.Base.++_$s++
                                             @ GHC.Types.Char
                                             (GHC.CString.unpackAppendCString#
                                                LamFunLexer.$fShowToken4
                                                (case GHC.Show.$wshowSignedInt
                                                        0#
                                                        wild2
                                                        (GHC.Types.[]
                                                           @ GHC.Types.Char) of ww9 { (#,#) ww10 ww11 ->
                                                 GHC.Base.++_$s++
                                                   @ GHC.Types.Char
                                                   (GHC.CString.unpackAppendCString#
                                                      LamFunLexer.$fShowToken3
                                                      (case GHC.Show.$wshowSignedInt
                                                              0#
                                                              wild4
                                                              (GHC.Types.[]
                                                                 @ GHC.Types.Char) of ww12 { (#,#) ww13 ww14 ->
                                                       GHC.Base.++_$s++
                                                         @ GHC.Types.Char
                                                         (GHC.CString.unpackAppendCString#
                                                            LamFunLexer.$fShowToken4
                                                            (case GHC.Show.$wshowSignedInt
                                                                    0#
                                                                    wild6
                                                                    (GHC.Types.[]
                                                                       @ GHC.Types.Char) of ww15 { (#,#) ww16 ww17 ->
                                                             GHC.Base.++_$s++
                                                               @ GHC.Types.Char
                                                               LamFunLexer.$fShowToken1
                                                               ww16
                                                               ww17 }))
                                                         ww13
                                                         ww14 }))
                                                   ww10
                                                   ww11 }))
                                             ww7
                                             ww8 }))
                                  -1# -> ww ww1 } }
                             -1# -> ww ww1 } }
                        -1# -> ww ww1 } }
                   -1# -> ww ww1 }) -}
841ad2858562c22d4e5d9cd55fadb55b
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> LamFunLexer.DropOrKeepLabel -> a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(1*C1(C1(C(U))),A,A)><S,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: LamFunLexer.DropOrKeepLabel)
                   (ww2 :: a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (eta :: GHC.Base.String) ->
                     case ww1 of wild {
                       LamFunLexer.Drop
                       -> GHC.Base.++ @ GHC.Types.Char LamFunLexer.$fShowDropOrKeep9 eta
                       LamFunLexer.Keep
                       -> GHC.Base.++ @ GHC.Types.Char LamFunLexer.$fShowDropOrKeep7 eta
                       LamFunLexer.New
                       -> GHC.Base.++ @ GHC.Types.Char LamFunLexer.$fShowDropOrKeep5 eta }
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w LamFunLexer.$fIsStringToken1 ww2
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x1 :: GHC.Base.String) ->
                      GHC.CString.unpackAppendCString#
                        LamFunLexer.$fShowDropOrKeep4
                        (GHC.CString.unpackAppendCString#
                           LamFunLexer.$fShowDropOrKeep3
                           (f (GHC.Base.++
                                 @ GHC.Types.Char
                                 GHC.Show.showCommaSpace1
                                 (GHC.CString.unpackAppendCString#
                                    LamFunLexer.$fShowDropOrKeep2
                                    (f1
                                       (GHC.CString.unpackAppendCString#
                                          LamFunLexer.$fShowDropOrKeep1
                                          x1))))))
                   1#
                   -> \ (x1 :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.CString.unpackAppendCString#
                           LamFunLexer.$fShowDropOrKeep4
                           (GHC.CString.unpackAppendCString#
                              LamFunLexer.$fShowDropOrKeep3
                              (f (GHC.Base.++
                                    @ GHC.Types.Char
                                    GHC.Show.showCommaSpace1
                                    (GHC.CString.unpackAppendCString#
                                       LamFunLexer.$fShowDropOrKeep2
                                       (f1
                                          (GHC.CString.unpackAppendCString#
                                             LamFunLexer.$fShowDropOrKeep1
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                GHC.Show.$fShow(,)2
                                                x1)))))))) }) -}
73f02fd9088bf7097a9de5a2df4483d2
  $w$cshowsPrec1 ::
    LamFunLexer.DropOrKeepLabel -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: LamFunLexer.DropOrKeepLabel)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   LamFunLexer.Drop
                   -> GHC.Base.++ @ GHC.Types.Char LamFunLexer.$fShowDropOrKeep9 w1
                   LamFunLexer.Keep
                   -> GHC.Base.++ @ GHC.Types.Char LamFunLexer.$fShowDropOrKeep7 w1
                   LamFunLexer.New
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        LamFunLexer.$fShowDropOrKeep5
                        w1 }) -}
e964bd01f2c4f4f05035a0c2793fbaf8
  $w$stokenizer ::
    LamFunLexer.TokenizerSettingsText
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (LamFunLexer.Row, LamFunLexer.Col)
    -> (# [LamFunLexer.DropOrKeep
             (LamFunLexer.Token Data.Text.Internal.Text)],
          (LamFunLexer.Row, LamFunLexer.Col) #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,U(U(U),U(U))>,
     Inline: [2] -}
f7349e06b15692fb65bb0032ed8f4c77
  $wblockDrop ::
    Data.Text.Internal.Text
    -> Data.Text.Internal.Text
    -> (# Data.Text.Internal.Text,
          Data.Text.Internal.Text
          -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
              Data.Text.Internal.Text) #)
  {- Arity: 2, Strictness: <L,U(U,U,U)><L,U(U,U,U)>, Inline: [2] -}
072a5232cc6bd00b4be1c839d0200ebd
  $wf ::
    Data.Text.Internal.Text
    -> (# [LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <L,U(U,U,U)>, Inline: [2],
     Unfolding: (\ (w :: Data.Text.Internal.Text) ->
                 (# GHC.Types.:
                      @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)
                      (LamFunLexer.DropOrKeep
                         @ Data.Text.Internal.Text
                         LamFunLexer.Drop
                         (case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                          let {
                            exit :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          let {
                            exit1 :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          let {
                            exit2 :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          letrec {
                            $wloop :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.>=# ww dt2 of lwild {
                                DEFAULT
                                -> let {
                                     j :: GHC.Prim.Int# = GHC.Prim.+# dt1 ww
                                   } in
                                   case GHC.Prim.indexWord16Array# dt j of r# { DEFAULT ->
                                   case GHC.Prim.ltWord# r# 55296## of lwild1 {
                                     DEFAULT
                                     -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                                          DEFAULT
                                          -> case GHC.Prim.indexWord16Array#
                                                    dt
                                                    (GHC.Prim.+# j 1#) of r#1 { DEFAULT ->
                                             case GHC.Prim.chr#
                                                    (GHC.Prim.+#
                                                       9216#
                                                       (GHC.Prim.+#
                                                          (GHC.Prim.uncheckedIShiftL#
                                                             (GHC.Prim.-#
                                                                (GHC.Prim.word2Int# r#)
                                                                55296#)
                                                             10#)
                                                          (GHC.Prim.word2Int# r#1))) of wild1 {
                                               DEFAULT -> exit ww
                                               '\t'# -> $wloop (GHC.Prim.+# ww 2#) } }
                                          1#
                                          -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                               DEFAULT -> exit1 ww
                                               '\t'# -> $wloop (GHC.Prim.+# ww 1#) } }
                                     1#
                                     -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                          DEFAULT -> exit2 ww
                                          '\t'# -> $wloop (GHC.Prim.+# ww 1#) } } }
                                1# -> wild }
                          } in
                          $wloop 0# }))
                      (GHC.Types.[] @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)),
                    case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                    let {
                      exit :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    let {
                      exit1 :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    let {
                      exit2 :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    letrec {
                      $wloop :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2] -}
                      = \ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                        case GHC.Prim.>=# ww1 dt2 of lwild {
                          DEFAULT
                          -> let {
                               j :: GHC.Prim.Int# = GHC.Prim.+# dt1 ww
                             } in
                             case GHC.Prim.indexWord16Array# dt j of r# { DEFAULT ->
                             case GHC.Prim.ltWord# r# 55296## of lwild1 {
                               DEFAULT
                               -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                                    DEFAULT
                                    -> case GHC.Prim.indexWord16Array#
                                              dt
                                              (GHC.Prim.+# j 1#) of r#1 { DEFAULT ->
                                       case GHC.Prim.chr#
                                              (GHC.Prim.+#
                                                 9216#
                                                 (GHC.Prim.+#
                                                    (GHC.Prim.uncheckedIShiftL#
                                                       (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                       10#)
                                                    (GHC.Prim.word2Int# r#1))) of wild1 {
                                         DEFAULT -> exit ww ww1
                                         '\t'#
                                         -> $wloop (GHC.Prim.+# ww 2#) (GHC.Prim.+# ww1 2#) } }
                                    1#
                                    -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                         DEFAULT -> exit1 ww ww1
                                         '\t'#
                                         -> $wloop (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#) } }
                               1#
                               -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                    DEFAULT -> exit2 ww ww1
                                    '\t'# -> $wloop (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#) } } }
                          1# -> Data.Text.Internal.empty }
                    } in
                    $wloop 0# 0# } #)) -}
354f3c9d8af0ce00b0c1671994958bac
  $wf1 ::
    Data.Text.Internal.Text
    -> (# [LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <L,U(U,U,U)>, Inline: [2],
     Unfolding: (\ (w :: Data.Text.Internal.Text) ->
                 (# GHC.Types.:
                      @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)
                      (LamFunLexer.DropOrKeep
                         @ Data.Text.Internal.Text
                         LamFunLexer.Drop
                         (case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                          let {
                            exit :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          let {
                            exit1 :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          let {
                            exit2 :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          letrec {
                            $wloop :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.>=# ww dt2 of lwild {
                                DEFAULT
                                -> let {
                                     j :: GHC.Prim.Int# = GHC.Prim.+# dt1 ww
                                   } in
                                   case GHC.Prim.indexWord16Array# dt j of r# { DEFAULT ->
                                   case GHC.Prim.ltWord# r# 55296## of lwild1 {
                                     DEFAULT
                                     -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                                          DEFAULT
                                          -> case GHC.Prim.indexWord16Array#
                                                    dt
                                                    (GHC.Prim.+# j 1#) of r#1 { DEFAULT ->
                                             case GHC.Prim.chr#
                                                    (GHC.Prim.+#
                                                       9216#
                                                       (GHC.Prim.+#
                                                          (GHC.Prim.uncheckedIShiftL#
                                                             (GHC.Prim.-#
                                                                (GHC.Prim.word2Int# r#)
                                                                55296#)
                                                             10#)
                                                          (GHC.Prim.word2Int# r#1))) of wild1 {
                                               DEFAULT -> exit ww
                                               '\n'# -> $wloop (GHC.Prim.+# ww 2#) } }
                                          1#
                                          -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                               DEFAULT -> exit1 ww
                                               '\n'# -> $wloop (GHC.Prim.+# ww 1#) } }
                                     1#
                                     -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                          DEFAULT -> exit2 ww
                                          '\n'# -> $wloop (GHC.Prim.+# ww 1#) } } }
                                1# -> wild }
                          } in
                          $wloop 0# }))
                      (GHC.Types.[] @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)),
                    case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                    let {
                      exit :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    let {
                      exit1 :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    let {
                      exit2 :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    letrec {
                      $wloop :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2] -}
                      = \ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                        case GHC.Prim.>=# ww1 dt2 of lwild {
                          DEFAULT
                          -> let {
                               j :: GHC.Prim.Int# = GHC.Prim.+# dt1 ww
                             } in
                             case GHC.Prim.indexWord16Array# dt j of r# { DEFAULT ->
                             case GHC.Prim.ltWord# r# 55296## of lwild1 {
                               DEFAULT
                               -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                                    DEFAULT
                                    -> case GHC.Prim.indexWord16Array#
                                              dt
                                              (GHC.Prim.+# j 1#) of r#1 { DEFAULT ->
                                       case GHC.Prim.chr#
                                              (GHC.Prim.+#
                                                 9216#
                                                 (GHC.Prim.+#
                                                    (GHC.Prim.uncheckedIShiftL#
                                                       (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                       10#)
                                                    (GHC.Prim.word2Int# r#1))) of wild1 {
                                         DEFAULT -> exit ww ww1
                                         '\n'#
                                         -> $wloop (GHC.Prim.+# ww 2#) (GHC.Prim.+# ww1 2#) } }
                                    1#
                                    -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                         DEFAULT -> exit1 ww ww1
                                         '\n'#
                                         -> $wloop (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#) } }
                               1#
                               -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                    DEFAULT -> exit2 ww ww1
                                    '\n'# -> $wloop (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#) } } }
                          1# -> Data.Text.Internal.empty }
                    } in
                    $wloop 0# 0# } #)) -}
6e679048447836b8e57f39d7686db1e3
  $wf2 ::
    Data.Text.Internal.Text
    -> (# [LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text #)
  {- Arity: 1, Strictness: <L,U(U,U,U)>, Inline: [2],
     Unfolding: (\ (w :: Data.Text.Internal.Text) ->
                 (# GHC.Types.:
                      @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)
                      (LamFunLexer.DropOrKeep
                         @ Data.Text.Internal.Text
                         LamFunLexer.Drop
                         (case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                          let {
                            exit :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          let {
                            exit1 :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          let {
                            exit2 :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                              case ww of wild2 {
                                DEFAULT -> Data.Text.Internal.Text dt dt1 wild2
                                0# -> Data.Text.Internal.empty }
                          } in
                          letrec {
                            $wloop :: GHC.Prim.Int# -> Data.Text.Internal.Text
                              <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                            = \ (ww :: GHC.Prim.Int#) ->
                              case GHC.Prim.>=# ww dt2 of lwild {
                                DEFAULT
                                -> let {
                                     j :: GHC.Prim.Int# = GHC.Prim.+# dt1 ww
                                   } in
                                   case GHC.Prim.indexWord16Array# dt j of r# { DEFAULT ->
                                   case GHC.Prim.ltWord# r# 55296## of lwild1 {
                                     DEFAULT
                                     -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                                          DEFAULT
                                          -> case GHC.Prim.indexWord16Array#
                                                    dt
                                                    (GHC.Prim.+# j 1#) of r#1 { DEFAULT ->
                                             case GHC.Prim.chr#
                                                    (GHC.Prim.+#
                                                       9216#
                                                       (GHC.Prim.+#
                                                          (GHC.Prim.uncheckedIShiftL#
                                                             (GHC.Prim.-#
                                                                (GHC.Prim.word2Int# r#)
                                                                55296#)
                                                             10#)
                                                          (GHC.Prim.word2Int# r#1))) of wild1 {
                                               DEFAULT -> exit ww
                                               ' '# -> $wloop (GHC.Prim.+# ww 2#) } }
                                          1#
                                          -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                               DEFAULT -> exit1 ww
                                               ' '# -> $wloop (GHC.Prim.+# ww 1#) } }
                                     1#
                                     -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                          DEFAULT -> exit2 ww
                                          ' '# -> $wloop (GHC.Prim.+# ww 1#) } } }
                                1# -> wild }
                          } in
                          $wloop 0# }))
                      (GHC.Types.[] @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)),
                    case w of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                    let {
                      exit :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    let {
                      exit1 :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    let {
                      exit2 :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <S,U><S,U>m -}
                      = \ (ww :: GHC.Prim.Int#)[OneShot]
                          (ww1 :: GHC.Prim.Int#)[OneShot] ->
                        Data.Text.Internal.Text
                          dt
                          (GHC.Prim.+# dt1 ww)
                          (GHC.Prim.-# dt2 ww1)
                    } in
                    letrec {
                      $wloop :: GHC.Prim.Int# -> GHC.Prim.Int# -> Data.Text.Internal.Text
                        <join 2> {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2] -}
                      = \ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                        case GHC.Prim.>=# ww1 dt2 of lwild {
                          DEFAULT
                          -> let {
                               j :: GHC.Prim.Int# = GHC.Prim.+# dt1 ww
                             } in
                             case GHC.Prim.indexWord16Array# dt j of r# { DEFAULT ->
                             case GHC.Prim.ltWord# r# 55296## of lwild1 {
                               DEFAULT
                               -> case GHC.Prim.gtWord# r# 56319## of lwild2 {
                                    DEFAULT
                                    -> case GHC.Prim.indexWord16Array#
                                              dt
                                              (GHC.Prim.+# j 1#) of r#1 { DEFAULT ->
                                       case GHC.Prim.chr#
                                              (GHC.Prim.+#
                                                 9216#
                                                 (GHC.Prim.+#
                                                    (GHC.Prim.uncheckedIShiftL#
                                                       (GHC.Prim.-# (GHC.Prim.word2Int# r#) 55296#)
                                                       10#)
                                                    (GHC.Prim.word2Int# r#1))) of wild1 {
                                         DEFAULT -> exit ww ww1
                                         ' '# -> $wloop (GHC.Prim.+# ww 2#) (GHC.Prim.+# ww1 2#) } }
                                    1#
                                    -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                         DEFAULT -> exit1 ww ww1
                                         ' '# -> $wloop (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#) } }
                               1#
                               -> case GHC.Prim.chr# (GHC.Prim.word2Int# r#) of wild1 {
                                    DEFAULT -> exit2 ww ww1
                                    ' '# -> $wloop (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#) } } }
                          1# -> Data.Text.Internal.empty }
                    } in
                    $wloop 0# 0# } #)) -}
83e0549075ce33a5e2e199eb8f9ce1eb
  $wquotes ::
    GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (# [LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>, Inline: [2] -}
0ddc102d379ec1423782a7546e48ce93
  $wtokenize ::
    (LamFunLexer.Row, LamFunLexer.Col)
    -> GHC.Prim.ByteArray#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> [LamFunLexer.Token Data.Text.Internal.Text]
  {- Arity: 4, Strictness: <L,U(U(U),U(U))><S,U><S,U><S,U>,
     Inline: [2],
     Unfolding: (\ (w :: (LamFunLexer.Row, LamFunLexer.Col))
                   (ww :: GHC.Prim.ByteArray#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Prim.Int#) ->
                 case LamFunLexer.$w$stokenizer
                        LamFunLexer.tokenize1
                        ww
                        ww1
                        ww2
                        w of ww3 { (#,#) ww4 ww5 ->
                 LamFunLexer.tokenize_go ww4 }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  newtype Col = Col GHC.Types.Int
8f2332b352b177c2329324164108499b
  data DropOrKeep a
    = DropOrKeep {label :: LamFunLexer.DropOrKeepLabel, content :: a}
73f02fd9088bf7097a9de5a2df4483d2
  data DropOrKeepLabel = Drop | Keep | New
f2c5a98949fb07f270f36c9e0675ac4d
  axiom LamFunLexer.Rep_Token::
      GHC.Generics.Rep (LamFunLexer.Token a)
        = GHC.Generics.D1
            ('GHC.Generics.MetaData
               "Token"
               "LamFunLexer"
               "LamFun-3.14.1-1NElG62CogO50XNaLIVWxW"
               'GHC.Types.False)
            (GHC.Generics.C1
               ('GHC.Generics.MetaCons
                  "Token" 'GHC.Generics.PrefixI 'GHC.Types.True)
               ((GHC.Generics.S1
                   ('GHC.Generics.MetaSel
                      ('GHC.Maybe.Just "unTok")
                      'GHC.Generics.NoSourceUnpackedness
                      'GHC.Generics.NoSourceStrictness
                      'GHC.Generics.DecidedLazy)
                   (GHC.Generics.Rec0 a)
                 GHC.Generics.:*: GHC.Generics.S1
                                    ('GHC.Generics.MetaSel
                                       ('GHC.Maybe.Just "rowStart")
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0 LamFunLexer.Row))
                GHC.Generics.:*: (GHC.Generics.S1
                                    ('GHC.Generics.MetaSel
                                       ('GHC.Maybe.Just "rowEnd")
                                       'GHC.Generics.NoSourceUnpackedness
                                       'GHC.Generics.NoSourceStrictness
                                       'GHC.Generics.DecidedLazy)
                                    (GHC.Generics.Rec0 LamFunLexer.Row)
                                  GHC.Generics.:*: (GHC.Generics.S1
                                                      ('GHC.Generics.MetaSel
                                                         ('GHC.Maybe.Just "colStart")
                                                         'GHC.Generics.NoSourceUnpackedness
                                                         'GHC.Generics.NoSourceStrictness
                                                         'GHC.Generics.DecidedLazy)
                                                      (GHC.Generics.Rec0 LamFunLexer.Col)
                                                    GHC.Generics.:*: GHC.Generics.S1
                                                                       ('GHC.Generics.MetaSel
                                                                          ('GHC.Maybe.Just "colEnd")
                                                                          'GHC.Generics.NoSourceUnpackedness
                                                                          'GHC.Generics.NoSourceStrictness
                                                                          'GHC.Generics.DecidedLazy)
                                                                       (GHC.Generics.Rec0
                                                                          LamFunLexer.Col)))))
332c1546bd09260727a773e99e195081
  newtype Row = Row GHC.Types.Int
f2c5a98949fb07f270f36c9e0675ac4d
  data Token a
    = Token {unTok :: a,
             rowStart :: LamFunLexer.Row,
             rowEnd :: LamFunLexer.Row,
             colStart :: LamFunLexer.Col,
             colEnd :: LamFunLexer.Col}
b5ab874f37468ed932d2b8c1ac714e88
  type TokenizerSettingsText =
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
f2c5a98949fb07f270f36c9e0675ac4d
  colEnd :: LamFunLexer.Token a -> LamFunLexer.Col
  RecSel Left LamFunLexer.Token
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLS),1*U(A,A,A,A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.Token a) ->
                 case ds of wild { LamFunLexer.Token ds1 ds2 ds3 ds4 ds5 ->
                 ds5 }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  colStart :: LamFunLexer.Token a -> LamFunLexer.Col
  RecSel Left LamFunLexer.Token
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSL),1*U(A,A,A,1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.Token a) ->
                 case ds of wild { LamFunLexer.Token ds1 ds2 ds3 ds4 ds5 ->
                 ds4 }) -}
8f2332b352b177c2329324164108499b
  content :: LamFunLexer.DropOrKeep a -> a
  RecSel Left LamFunLexer.DropOrKeep
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.DropOrKeep a) ->
                 case ds of wild { LamFunLexer.DropOrKeep ds1 ds2 -> ds2 }) -}
484eeb2c5fd9547c6e3ba606d3968c2d
  defaultPosition :: (LamFunLexer.Row, LamFunLexer.Col)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((LamFunLexer.$fIsStringToken1
                    `cast`
                  (Sym (LamFunLexer.N:Row[0])),
                  LamFunLexer.$fIsStringToken1
                    `cast`
                  (Sym (LamFunLexer.N:Col[0])))) -}
8dc36495a96ccb957e874bb9b1d01fd5
  ignoreComment ::
    (Data.Text.Internal.Text,
     Data.Text.Internal.Text
     -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
         Data.Text.Internal.Text))
  {- Unfolding: (case LamFunLexer.$wblockDrop
                        LamFunLexer.tokenize16
                        LamFunLexer.tokenize14 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
5c61a96aec506226fcea332e907b8b61
  ignoreComment2 ::
    (Data.Text.Internal.Text,
     Data.Text.Internal.Text
     -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
         Data.Text.Internal.Text))
  {- Unfolding: (case LamFunLexer.$wblockDrop
                        LamFunLexer.tokenize12
                        LamFunLexer.tokenize10 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
8f2332b352b177c2329324164108499b
  label :: LamFunLexer.DropOrKeep a -> LamFunLexer.DropOrKeepLabel
  RecSel Left LamFunLexer.DropOrKeep
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.DropOrKeep a) ->
                 case ds of wild { LamFunLexer.DropOrKeep ds1 ds2 -> ds1 }) -}
2a72f77b7c1a8c677fe6a7575ca42bb5
  newline ::
    (Data.Text.Internal.Text,
     Data.Text.Internal.Text
     -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
         Data.Text.Internal.Text))
  {- Strictness: m,
     Unfolding: ((LamFunLexer.tokenize14, LamFunLexer.tokenize_f1)) -}
9b68619aea9735b7a1c3f7b6ff9e1ae5
  quotes ::
    (Data.Text.Internal.Text,
     Data.Text.Internal.Text
     -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
         Data.Text.Internal.Text))
  {- Strictness: m,
     Unfolding: ((LamFunLexer.reservedKeywords82,
                  LamFunLexer.tokenize18)) -}
f75dac88c65ec50fd1a0db76c20706a8
  reservedKeywords :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords82
                   LamFunLexer.reservedKeywords1) -}
258e960d16b86276affab221d4754334
  reservedKeywords1 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords80
                   LamFunLexer.reservedKeywords2) -}
93736368b6bd867b98c44f981fe76ec7
  reservedKeywords10 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords64
                   LamFunLexer.reservedKeywords11) -}
575fb19828e63af68dbcbc13f780aae4
  reservedKeywords11 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords62
                   LamFunLexer.reservedKeywords12) -}
556db1fc1b5608ddc4c75506bae5c9f0
  reservedKeywords12 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords60
                   LamFunLexer.reservedKeywords13) -}
bc9570d86ac05141a54b9c76c5ebe237
  reservedKeywords13 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords58
                   LamFunLexer.reservedKeywords14) -}
d45531cf8322e5283d8cc869991f5a81
  reservedKeywords14 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords56
                   LamFunLexer.reservedKeywords15) -}
fb82ead0b2198aa16e7ba7028c09cb26
  reservedKeywords15 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords54
                   LamFunLexer.reservedKeywords16) -}
55c8ccfadd206992a4dec1c42e64336a
  reservedKeywords16 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords53
                   LamFunLexer.reservedKeywords17) -}
ac8927149b2f9a5896ac403cea53ba61
  reservedKeywords17 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords51
                   LamFunLexer.reservedKeywords18) -}
55a9210a3cb0466eeba01bfca0c7ca29
  reservedKeywords18 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords49
                   LamFunLexer.reservedKeywords19) -}
4e3a99ec07a38731c3a42bfb001d8452
  reservedKeywords19 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords47
                   LamFunLexer.reservedKeywords20) -}
6979fcffac2b1a68786ca7c110db92c7
  reservedKeywords2 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords79
                   LamFunLexer.reservedKeywords3) -}
6e628ce42ef28739cae9a7bd57eaa4a7
  reservedKeywords20 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords45
                   LamFunLexer.reservedKeywords21) -}
2f9266eb401c73a436e4bb0750b2f407
  reservedKeywords21 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords43
                   LamFunLexer.reservedKeywords22) -}
abc027371d09545a74af5324815b7212
  reservedKeywords22 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords41
                   LamFunLexer.reservedKeywords23) -}
315f1a6cf2a404eb9a7fc4b78792b594
  reservedKeywords23 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords39
                   LamFunLexer.reservedKeywords24) -}
cd8d496026a9c181103000faf46b47a4
  reservedKeywords24 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords37
                   LamFunLexer.reservedKeywords25) -}
d70d8c7f05289ad149a579f04b8e3455
  reservedKeywords25 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords35
                   LamFunLexer.reservedKeywords26) -}
f153a048394c25d692e871e6156eb4d8
  reservedKeywords26 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords33
                   LamFunLexer.reservedKeywords27) -}
326bc7db229c8f0aecf93260ca903365
  reservedKeywords27 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords31
                   LamFunLexer.reservedKeywords28) -}
08650731b9287658d519a193a5664a66
  reservedKeywords28 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords29
                   (GHC.Types.[] @ Data.Text.Internal.Text)) -}
4a4f2438ad723cb95436167d451e7cd1
  reservedKeywords29 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords30) -}
d96ab7c9738961163e5097bc3626cfe1
  reservedKeywords3 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords77
                   LamFunLexer.reservedKeywords4) -}
b077f0db7f3892609c2c0e1fa9c7b221
  reservedKeywords30 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!"#) -}
bc96164cbf9c2e82416fb0092c43ad70
  reservedKeywords31 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords32) -}
82d512712212e4e88313a21f7ac0e87a
  reservedKeywords32 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("!="#) -}
674ed8cd66b737892d0942a1752641cb
  reservedKeywords33 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords34) -}
bdd622415eff1fdbc3ac7563fb8ef039
  reservedKeywords34 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("=="#) -}
6065ab3f6bcba259525bb398ee8afda6
  reservedKeywords35 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords36) -}
f4ebb3b867ba9d394405d6413db64a9f
  reservedKeywords36 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">="#) -}
282a4d64dadc7bf0450461c061e5b2d6
  reservedKeywords37 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords38) -}
b923f8f0287a677bea62ea2087c5e518
  reservedKeywords38 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (">"#) -}
6d8a3d1f2a1022caaad96a230e42e0fa
  reservedKeywords39 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords40) -}
a03eed11ae785bd3ec66a498bacc9b01
  reservedKeywords4 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords75
                   LamFunLexer.reservedKeywords5) -}
435d79a42bba6b97e5f1c8dc0a4943f9
  reservedKeywords40 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<="#) -}
9f62f47404313a87e7165a31654cb267
  reservedKeywords41 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords42) -}
4f9a80118826027a8c35d1a095773018
  reservedKeywords42 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("<"#) -}
e8db75c01f38e54cbcdba58399134e1a
  reservedKeywords43 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords44) -}
277528c4761d72420a6996b7091f1276
  reservedKeywords44 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("/"#) -}
250b7c38f600cf839e6d631edaa6042b
  reservedKeywords45 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords46) -}
229491ca3325505e86f8ab157f23071c
  reservedKeywords46 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("*"#) -}
53361cae87e67a38dab0dde2671f79a3
  reservedKeywords47 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords48) -}
7d22f521b22f64ff143b11f406b8817a
  reservedKeywords48 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-"#) -}
349312b9f8926f89910d35a7fde35496
  reservedKeywords49 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords50) -}
a5208dc79aa62314aaf203dc0739bfd5
  reservedKeywords5 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords73
                   LamFunLexer.reservedKeywords6) -}
464746556574fb28a30754754a0abeac
  reservedKeywords50 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("+"#) -}
1cefa5f1f9f3eac68bdb12cef5906a50
  reservedKeywords51 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords52) -}
11599fd16f123c9bcca21619f0a5f1f9
  reservedKeywords52 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("&"#) -}
2647a752ea2eb920e21b5e0441d4c991
  reservedKeywords53 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.$fShowToken4) -}
88d5d71c2c5092e48e893989bdcbee76
  reservedKeywords54 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords55) -}
3817bf64caea9e13f08175a312a38885
  reservedKeywords55 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (";"#) -}
96886e610d88e9afd8472f274d2240e4
  reservedKeywords56 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords57) -}
81541d8a1255f4429fca5a77845fd6b9
  reservedKeywords57 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (";;"#) -}
47066280a3e85be8a459aa73a833b984
  reservedKeywords58 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords59) -}
5ec7d8702aecae24871a99e62ff6d55c
  reservedKeywords59 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("."#) -}
262a86bba24e121214f1fd3cd54eb1ae
  reservedKeywords6 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords72
                   LamFunLexer.reservedKeywords7) -}
0d5219c29af9f11ccf4a93c9fe5ca1f3
  reservedKeywords60 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords61) -}
58bdc67cdbacf29cd13c0353136446fc
  reservedKeywords61 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\\"#) -}
d5a0ffeb95eb9354cf8fd0c201ee3444
  reservedKeywords62 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords63) -}
ffde517836c01f690c6b87533354ff2d
  reservedKeywords63 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("_"#) -}
c00de4a03df080a447d7c952fe98b337
  reservedKeywords64 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords65) -}
fadbb7122926ae6dcc17eb60d03db545
  reservedKeywords65 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":="#) -}
bfc9583eb453c197223f4cd4c04b73a7
  reservedKeywords66 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords67) -}
1de5950a008406a2148d260d996044e8
  reservedKeywords67 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("="#) -}
2adfc34893cdf84029e6676589d4fd51
  reservedKeywords68 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords69) -}
a96e08a43464e4f1851ca8bd4e860bcf
  reservedKeywords69 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (","#) -}
873b77ed827515351ee48cf293d09236
  reservedKeywords7 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords70
                   LamFunLexer.reservedKeywords8) -}
5ed6776b48a2ca572cd4fbf865594407
  reservedKeywords70 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords71) -}
8df861d3dccbd0542a09061c77246398
  reservedKeywords71 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("->"#) -}
5a8b8171d311a91c7f952ab045db8777
  reservedKeywords72 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.$fShowDropOrKeep1) -}
4304057717ae03de9be2690a3aad638c
  reservedKeywords73 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords74) -}
b70a625e2ff6c69b15eca5e31e95ed3f
  reservedKeywords74 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{"#) -}
1bfa75caaed17ee54879d0b78f6ffd8b
  reservedKeywords75 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords76) -}
aa1617ff09bf070d0a9c7f0331606cc9
  reservedKeywords76 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("]"#) -}
1435118a18e0a990c886456073863940
  reservedKeywords77 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords78) -}
3f14e61a42a3f23c8177bbcc65e65f35
  reservedKeywords78 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("["#) -}
cb121cf72a01244a1c11eac2dafc0c48
  reservedKeywords79 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.$fShowToken2) -}
b4d90fcf1d5abbe1f86acd84eb59b26b
  reservedKeywords8 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords68
                   LamFunLexer.reservedKeywords9) -}
e9b8fcbef68d3a4e560d307573799a11
  reservedKeywords80 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords81) -}
53b0f316e206afda44fb81ea954be402
  reservedKeywords81 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("("#) -}
e2c9f9de058ca3c1585d168aceac67d5
  reservedKeywords82 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.reservedKeywords83) -}
fd43809cd64991a596c9512a81480398
  reservedKeywords83 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\""#) -}
1309af41552107a65e7dbd02900e1e47
  reservedKeywords9 :: [Data.Text.Internal.Text]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Data.Text.Internal.Text
                   LamFunLexer.reservedKeywords66
                   LamFunLexer.reservedKeywords10) -}
f2c5a98949fb07f270f36c9e0675ac4d
  rowEnd :: LamFunLexer.Token a -> LamFunLexer.Row
  RecSel Left LamFunLexer.Token
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLL),1*U(A,A,1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.Token a) ->
                 case ds of wild { LamFunLexer.Token ds1 ds2 ds3 ds4 ds5 ->
                 ds3 }) -}
f2c5a98949fb07f270f36c9e0675ac4d
  rowStart :: LamFunLexer.Token a -> LamFunLexer.Row
  RecSel Left LamFunLexer.Token
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLL),1*U(A,1*U(U),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.Token a) ->
                 case ds of wild { LamFunLexer.Token ds1 ds2 ds3 ds4 ds5 ->
                 ds2 }) -}
0c59181466101fe148c695378f03bdfb
  tab ::
    (Data.Text.Internal.Text,
     Data.Text.Internal.Text
     -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
         Data.Text.Internal.Text))
  {- Strictness: m,
     Unfolding: ((LamFunLexer.tokenize19, LamFunLexer.tokenize_f)) -}
a8ff9fb97bdcc99b4ddb387e131c685b
  tokenize ::
    (LamFunLexer.Row, LamFunLexer.Col)
    -> Data.Text.Internal.Text
    -> [LamFunLexer.Token Data.Text.Internal.Text]
  {- Arity: 2, Strictness: <L,U(U(U),U(U))><S(SSS),1*U(U,U,U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (LamFunLexer.Row, LamFunLexer.Col))
                   (w1 :: Data.Text.Internal.Text) ->
                 case w1 of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 LamFunLexer.$wtokenize w ww1 ww2 ww3 }) -}
164ffca4f115794114353fdb9aa2c453
  tokenize1 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.whitespace
                   LamFunLexer.tokenize2) -}
68bd6680a49c1d056326b2f1d2c362ee
  tokenize10 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.tokenize11) -}
13941b97296384b8beb944ae79537364
  tokenize11 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("-}"#) -}
3f4e202a4bccb58a79a0f93cac5eefeb
  tokenize12 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.tokenize13) -}
b277109f23b48d748bb0747a2e1fd3d4
  tokenize13 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("{-"#) -}
1c14e0364e187d9c6666d1ec39fd9989
  tokenize14 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.tokenize15) -}
4ed0101140f21ea29fc0a58b631bf2f8
  tokenize15 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
1ccb094a941b6b53de4c1b01facf271f
  tokenize16 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.tokenize17) -}
8b83ec123f39b70a2a24571788fcfa8a
  tokenize17 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("--"#) -}
a74d06b79134c7e5ec98d6e22d2be932
  tokenize18 ::
    Data.Text.Internal.Text
    -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
        Data.Text.Internal.Text)
  {- Arity: 1, Strictness: <S(SSS),1*U(U,U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                 case LamFunLexer.$wquotes ww1 ww2 ww3 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6) } }) -}
2618b524d8029e4a45da506448e6caac
  tokenize19 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.tokenize20) -}
afac6f490940bb29870121b4e097bab7
  tokenize2 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.newline
                   LamFunLexer.tokenize3) -}
34440cf5f99da4115acf43fa810571e0
  tokenize20 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\t"#) -}
bdcc5455d2adcd0bd5fa390387c87dae
  tokenize21 :: Data.Text.Internal.Text
  {- Unfolding: (Data.Text.Show.unpackCString#
                   LamFunLexer.tokenize22) -}
8c6edf1914a9f2c02db3657e2dc38052
  tokenize22 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" "#) -}
8c31f88fdb8f881bf66904c7c429823a
  tokenize3 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.tab
                   LamFunLexer.tokenize4) -}
2c21095b5cf8ca0846ee9f7ae450d062
  tokenize4 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.quotes
                   LamFunLexer.tokenize5) -}
b7a3a6dc9e4b0b7982587998cafa6ba4
  tokenize5 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.ignoreComment
                   LamFunLexer.tokenize6) -}
23215d7d4ccf349eb3a0dbfff28c388c
  tokenize6 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.ignoreComment2
                   LamFunLexer.tokenize7) -}
48c3e7bd3d5a10e79cb5163e321f6d57
  tokenize7 ::
    [(Data.Text.Internal.Text,
      Data.Text.Internal.Text
      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
          Data.Text.Internal.Text))]
  {- Unfolding: (GHC.Base.map
                   @ Data.Text.Internal.Text
                   @ (Data.Text.Internal.Text,
                      Data.Text.Internal.Text
                      -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
                          Data.Text.Internal.Text))
                   LamFunLexer.tokenize9
                   (Data.OldList.sortBy
                      @ Data.Text.Internal.Text
                      LamFunLexer.tokenize8
                      LamFunLexer.reservedKeywords)) -}
9d8d7c963b6e935bea50a3c92de15893
  tokenize8 ::
    Data.Text.Internal.Text
    -> Data.Text.Internal.Text -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLS),1*U(U,U,U)><S(LSS),1*U(U,U,U)>,
     Unfolding: (\ (a :: Data.Text.Internal.Text)
                   (b :: Data.Text.Internal.Text)[OneShot] ->
                 case a of wild { Data.Text.Internal.Text dt dt1 dt2 ->
                 case b of wild1 { Data.Text.Internal.Text dt4 dt5 dt6 ->
                 let {
                   end :: GHC.Prim.Int# = GHC.Prim.+# dt5 dt6
                 } in
                 let {
                   $w$j1 :: GHC.Prim.Int# -> GHC.Types.Ordering
                     <join 1> {- Arity: 1, Strictness: <S,U>, Inline: [2] -}
                   = \ (w :: GHC.Prim.Int#)[OneShot] ->
                     case GHC.Prim.<# dt2 w of lwild {
                       DEFAULT
                       -> let {
                            len :: GHC.Prim.Int# = GHC.Prim.uncheckedIShiftRA# dt2 1#
                          } in
                          let {
                            dt3 :: GHC.Prim.Int# = GHC.Prim.*# 2# w
                          } in
                          case GHC.Prim.># len dt3 of lwild1 {
                            DEFAULT
                            -> let {
                                 $j :: GHC.Types.Ordering <join 0>
                                 = Data.Text.$w$ccompare dt dt1 dt2 dt4 dt5 dt6
                               } in
                               let {
                                 $j1 :: GHC.Types.Ordering <join 0>
                                 = let {
                                     end1 :: GHC.Prim.Int# = GHC.Prim.+# dt1 dt2
                                   } in
                                   let {
                                     exit :: GHC.Prim.Int# -> GHC.Types.Ordering
                                       <join 1> {- Arity: 1, Strictness: <S,U> -}
                                     = \ (ww :: GHC.Prim.Int#)[OneShot] ->
                                       case GHC.Prim.<# ww w of lwild2 {
                                         DEFAULT
                                         -> case GHC.Prim.==# ww w of lwild3 {
                                              DEFAULT -> GHC.Types.LT 1# -> $j }
                                         1# -> GHC.Types.GT }
                                   } in
                                   letrec {
                                     $wloop_cmp :: GHC.Prim.Int#
                                                   -> GHC.Prim.Int# -> GHC.Types.Ordering
                                       <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
                                     = \ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                                       case GHC.Prim.>=# ww1 end1 of lwild2 {
                                         DEFAULT
                                         -> case GHC.Prim.indexWord16Array#
                                                   dt
                                                   ww1 of r# { DEFAULT ->
                                            case GHC.Prim.geWord# r# 55296## of lwild3 {
                                              DEFAULT
                                              -> case GHC.Prim.># ww w of lwild4 {
                                                   DEFAULT
                                                   -> $wloop_cmp
                                                        (GHC.Prim.+# ww 1#)
                                                        (GHC.Prim.+# ww1 1#)
                                                   1# -> GHC.Types.LT }
                                              1#
                                              -> case GHC.Prim.leWord# r# 56319## of lwild4 {
                                                   DEFAULT
                                                   -> case GHC.Prim.># ww w of lwild5 {
                                                        DEFAULT
                                                        -> $wloop_cmp
                                                             (GHC.Prim.+# ww 1#)
                                                             (GHC.Prim.+# ww1 1#)
                                                        1# -> GHC.Types.LT }
                                                   1#
                                                   -> case GHC.Prim.># ww w of lwild5 {
                                                        DEFAULT
                                                        -> $wloop_cmp
                                                             (GHC.Prim.+# ww 1#)
                                                             (GHC.Prim.+# ww1 2#)
                                                        1# -> GHC.Types.LT } } } }
                                         1# -> exit ww }
                                   } in
                                   $wloop_cmp 0# dt1
                               } in
                               case GHC.Prim.==# len dt2 of lwild2 {
                                 DEFAULT -> $j1
                                 1#
                                 -> case GHC.Prim.==# len w of lwild3 {
                                      DEFAULT -> $j1
                                      1#
                                      -> case GHC.Prim.==# len dt3 of lwild4 {
                                           DEFAULT -> $j1 1# -> $j } } }
                            1# -> GHC.Types.LT }
                       1# -> GHC.Types.GT }
                 } in
                 letrec {
                   $wloop_length :: GHC.Prim.Int#
                                    -> GHC.Prim.Int# -> GHC.Types.Ordering
                     <join 2> {- Arity: 2, Strictness: <S,U><S,U>, Inline: [2] -}
                   = \ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Prim.Int#) ->
                     case GHC.Prim.>=# ww1 end of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexWord16Array# dt4 ww1 of r# { DEFAULT ->
                          case GHC.Prim.geWord# r# 55296## of lwild1 {
                            DEFAULT -> $wloop_length (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#)
                            1#
                            -> case GHC.Prim.leWord# r# 56319## of lwild2 {
                                 DEFAULT -> $wloop_length (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 1#)
                                 1# -> $wloop_length (GHC.Prim.+# ww 1#) (GHC.Prim.+# ww1 2#) } } }
                       1# -> $w$j1 ww }
                 } in
                 $wloop_length 0# dt5 } }) -}
fbf94920a4ecf1ba2e7ef3a85402c635
  tokenize9 ::
    Data.Text.Internal.Text
    -> (Data.Text.Internal.Text,
        Data.Text.Internal.Text
        -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
            Data.Text.Internal.Text))
  {- Arity: 1, Strictness: <L,U(U,U,U)>m,
     Unfolding: (\ (w :: Data.Text.Internal.Text) ->
                 let {
                   lvl17 :: LamFunLexer.DropOrKeep Data.Text.Internal.Text
                   = LamFunLexer.DropOrKeep
                       @ Data.Text.Internal.Text
                       LamFunLexer.New
                       w
                 } in
                 let {
                   lvl18 :: [LamFunLexer.DropOrKeep Data.Text.Internal.Text]
                   = GHC.Types.:
                       @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text)
                       lvl17
                       (GHC.Types.[] @ (LamFunLexer.DropOrKeep Data.Text.Internal.Text))
                 } in
                 (w,
                  \ (x1 :: Data.Text.Internal.Text) ->
                  (lvl18,
                   case w of ww { Data.Text.Internal.Text ww1 ww2 ww3 ->
                   case x1 of ww4 { Data.Text.Internal.Text ww5 ww6 ww7 ->
                   case Data.Text.$wstripPrefix ww1 ww2 ww3 ww5 ww6 ww7 of wild {
                     GHC.Maybe.Nothing -> Data.Maybe.fromJust1 @ Data.Text.Internal.Text
                     GHC.Maybe.Just x2 -> x2 } } }))) -}
7e1124b1f8bd15d08d5bffc3a32353cb
  tokenize_f ::
    Data.Text.Internal.Text
    -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
        Data.Text.Internal.Text)
  {- Arity: 1, Strictness: <L,U(U,U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case LamFunLexer.$wf w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
fa0aa02c73aa4a4f3cd471a2f6d2bf3d
  tokenize_f1 ::
    Data.Text.Internal.Text
    -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
        Data.Text.Internal.Text)
  {- Arity: 1, Strictness: <L,U(U,U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case LamFunLexer.$wf1 w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
0115f7409c75be524ea1bb244672dc82
  tokenize_f2 ::
    Data.Text.Internal.Text
    -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
        Data.Text.Internal.Text)
  {- Arity: 1, Strictness: <L,U(U,U,U)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Data.Text.Internal.Text) ->
                 case LamFunLexer.$wf2 w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
49229ae69c9d3e5025a0c3f473f47099
  tokenize_go ::
    [LamFunLexer.DropOrKeep
       (LamFunLexer.Token Data.Text.Internal.Text)]
    -> [LamFunLexer.Token Data.Text.Internal.Text]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f2c5a98949fb07f270f36c9e0675ac4d
  unTok :: LamFunLexer.Token a -> a
  RecSel Left LamFunLexer.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLLL),1*U(1*U,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: LamFunLexer.Token a) ->
                 case ds of wild { LamFunLexer.Token ds1 ds2 ds3 ds4 ds5 ->
                 ds1 }) -}
7d6776d4c7572f9210d8f04724b9612b
  whitespace ::
    (Data.Text.Internal.Text,
     Data.Text.Internal.Text
     -> ([LamFunLexer.DropOrKeep Data.Text.Internal.Text],
         Data.Text.Internal.Text))
  {- Strictness: m,
     Unfolding: ((LamFunLexer.tokenize21, LamFunLexer.tokenize_f2)) -}
instance GHC.Classes.Eq [LamFunLexer.Col] = LamFunLexer.$fEqCol
instance GHC.Classes.Eq [LamFunLexer.DropOrKeepLabel]
  = LamFunLexer.$fEqDropOrKeepLabel
instance GHC.Classes.Eq [LamFunLexer.Row] = LamFunLexer.$fEqRow
instance GHC.Classes.Eq [LamFunLexer.Token] = LamFunLexer.$fEqToken
instance GHC.Base.Functor [LamFunLexer.DropOrKeep]
  = LamFunLexer.$fFunctorDropOrKeep
instance GHC.Generics.Generic [LamFunLexer.Token]
  = LamFunLexer.$fGenericToken
instance Data.Hashable.Class.Hashable [LamFunLexer.Col]
  = LamFunLexer.$fHashableCol
instance Data.Hashable.Class.Hashable [LamFunLexer.Row]
  = LamFunLexer.$fHashableRow
instance Data.Hashable.Class.Hashable [LamFunLexer.Token]
  = LamFunLexer.$fHashableToken
instance Data.String.IsString [LamFunLexer.Token]
  = LamFunLexer.$fIsStringToken
instance GHC.Num.Num [LamFunLexer.Col] = LamFunLexer.$fNumCol
instance GHC.Num.Num [LamFunLexer.Row] = LamFunLexer.$fNumRow
instance GHC.Classes.Ord [LamFunLexer.Token]
  = LamFunLexer.$fOrdToken
instance GHC.Show.Show [LamFunLexer.Col] = LamFunLexer.$fShowCol
instance GHC.Show.Show [LamFunLexer.DropOrKeep]
  = LamFunLexer.$fShowDropOrKeep
instance GHC.Show.Show [LamFunLexer.DropOrKeepLabel]
  = LamFunLexer.$fShowDropOrKeepLabel
instance GHC.Show.Show [LamFunLexer.Row] = LamFunLexer.$fShowRow
instance GHC.Show.Show [LamFunLexer.Token]
  = LamFunLexer.$fShowToken
instance Data.String.Conv.StringConv [LamFunLexer.Token, .]
  = LamFunLexer.$fStringConvTokenb
family instance GHC.Generics.Rep [LamFunLexer.Token]
  = LamFunLexer.Rep_Token
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

