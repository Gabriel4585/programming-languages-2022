
==================== FINAL INTERFACE ====================
2019-11-21 22:26:15.963373 UTC

interface LamFun-3.14.1-1NElG62CogO50XNaLIVWxW:LamFunSyntax [family instance module] 8064
  interface hash: e3caea7fa61d35737c81e47b6f4ec99b
  ABI hash: ac1b0607f12c31259d1294cbc218e4ef
  export-list hash: dc40609dbddb7fe2711252054a4d6645
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 161252abef5c64c85f7525fac778cfcc
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: True
  where
exports:
  LamFunSyntax.unsafeMkAssign_
  LamFunSyntax.unsafeMkBoolean_
  LamFunSyntax.unsafeMkCase_
  LamFunSyntax.unsafeMkCons_
  LamFunSyntax.unsafeMkContents_
  LamFunSyntax.unsafeMkDefine_
  LamFunSyntax.unsafeMkLet_
  LamFunSyntax.unsafeMkNil_
  LamFunSyntax.unsafeMkNumber_
  LamFunSyntax.unsafeMkRec_
  LamFunSyntax.unsafeMkSequence_
  LamFunSyntax.unsafeMkStrLit_
  LamFunSyntax.unsafeMkWhile_
  LamFunSyntax.<:
  LamFunSyntax.Defn_{LamFunSyntax.Rec_ LamFunSyntax.Val_}
  LamFunSyntax.Expr_{LamFunSyntax.App_ LamFunSyntax.Assign_ LamFunSyntax.Boolean_ LamFunSyntax.Case_ LamFunSyntax.Cons_ LamFunSyntax.Contents_ LamFunSyntax.Lambda_ LamFunSyntax.Let_ LamFunSyntax.Nil_ LamFunSyntax.Number_ LamFunSyntax.Sequence_ LamFunSyntax.StrLit_ LamFunSyntax.Variable_ LamFunSyntax.While_}
  LamFunSyntax.LamArraySym0
  LamFunSyntax.LamCBNSym0
  LamFunSyntax.LamCBVSym0
  LamFunSyntax.LamMemSym0
  LamFunSyntax.LamNatSym0
  LamFunSyntax.LamRecSym0
  LamFunSyntax.Program_{LamFunSyntax.Calculate_ LamFunSyntax.Define_}
  LamFunSyntax.SVersion
  LamFunSyntax.Version{LamFunSyntax.LamArray LamFunSyntax.LamCBN LamFunSyntax.LamCBV LamFunSyntax.LamMem LamFunSyntax.LamNat LamFunSyntax.LamRec}
  Data.Singletons.Internal.Sing{LamFunSyntax.SLamArray LamFunSyntax.SLamCBN LamFunSyntax.SLamCBV LamFunSyntax.SLamMem LamFunSyntax.SLamNat LamFunSyntax.SLamRec}
module dependencies:
package dependencies: array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      ghc-boot-th-8.6.4 ghc-prim-0.5.3 hashable-1.2.7.0
                      integer-gmp-1.0.2.0 mtl-2.2.2 pretty-1.1.3.6 primitive-0.6.4.0
                      safe-0.3.17 singletons-2.5.1 syb-0.7 template-haskell-2.14.0.0
                      text-1.2.3.1 th-abstraction-0.2.11.0 th-desugar-1.9
                      th-expand-syns-0.4.4.0 th-lift-0.7.11 th-lift-instances-0.1.12
                      th-orphans-0.13.6 th-reify-many-0.1.8 transformers-0.5.6.2
                      vector-0.12.0.2
orphans: hashable-1.2.7.0:Data.Hashable.Generic
         singletons-2.5.1:Data.Singletons
         singletons-2.5.1:Data.Singletons.Prelude.Semigroup
         singletons-2.5.1:Data.Singletons.Prelude.Applicative
         singletons-2.5.1:Data.Singletons.Prelude.Const
         singletons-2.5.1:Data.Singletons.Prelude.Functor
         singletons-2.5.1:Data.Singletons.Prelude.Identity
         singletons-2.5.1:Data.Singletons.Prelude.Monoid
         singletons-2.5.1:Data.Singletons.Prelude.Semigroup.Internal
         singletons-2.5.1:Data.Singletons.TypeLits
         singletons-2.5.1:Data.Singletons.ShowSing
         singletons-2.5.1:Data.Singletons.TypeLits.Internal
         singletons-2.5.1:Data.Singletons.Prelude.Ord
         singletons-2.5.1:Data.Singletons.Prelude.Instances
         singletons-2.5.1:Data.Singletons.Decide
         th-orphans-0.13.6:Language.Haskell.TH.Instances
         th-lift-0.7.11:Language.Haskell.TH.Lift
         th-lift-instances-0.1.12:Instances.TH.Lift
         text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show vector-0.12.0.2:Data.Vector.Unboxed
         vector-0.12.0.2:Data.Vector.Fusion.Bundle
         transformers-0.5.6.2:Control.Monad.Trans.Error
         syb-0.7:Data.Generics.Instances base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.Graph
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.4:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.4:GHC.LanguageExtensions.Type
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array
                         primitive-0.6.4.0:Data.Primitive.ByteArray
                         primitive-0.6.4.0:Data.Primitive.PrimArray
                         primitive-0.6.4.0:Data.Primitive.SmallArray
                         primitive-0.6.4.0:Data.Primitive.UnliftedArray
                         singletons-2.5.1:Data.Singletons
                         singletons-2.5.1:Data.Singletons.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.Applicative
                         singletons-2.5.1:Data.Singletons.Prelude.Base
                         singletons-2.5.1:Data.Singletons.Prelude.Bool
                         singletons-2.5.1:Data.Singletons.Prelude.Const
                         singletons-2.5.1:Data.Singletons.Prelude.Either
                         singletons-2.5.1:Data.Singletons.Prelude.Enum
                         singletons-2.5.1:Data.Singletons.Prelude.Eq
                         singletons-2.5.1:Data.Singletons.Prelude.Foldable
                         singletons-2.5.1:Data.Singletons.Prelude.Functor
                         singletons-2.5.1:Data.Singletons.Prelude.Identity
                         singletons-2.5.1:Data.Singletons.Prelude.Instances
                         singletons-2.5.1:Data.Singletons.Prelude.IsString
                         singletons-2.5.1:Data.Singletons.Prelude.List.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.List.Internal.Disambiguation
                         singletons-2.5.1:Data.Singletons.Prelude.Maybe
                         singletons-2.5.1:Data.Singletons.Prelude.Monad.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.Monoid
                         singletons-2.5.1:Data.Singletons.Prelude.Num
                         singletons-2.5.1:Data.Singletons.Prelude.Ord
                         singletons-2.5.1:Data.Singletons.Prelude.Semigroup
                         singletons-2.5.1:Data.Singletons.Prelude.Semigroup.Internal
                         singletons-2.5.1:Data.Singletons.Prelude.Show
                         singletons-2.5.1:Data.Singletons.Prelude.Traversable
                         singletons-2.5.1:Data.Singletons.Prelude.Tuple
                         singletons-2.5.1:Data.Singletons.Syntax
                         singletons-2.5.1:Data.Singletons.TypeLits
                         singletons-2.5.1:Data.Singletons.TypeLits.Internal
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         th-abstraction-0.2.11.0:Language.Haskell.TH.Datatype
                         th-desugar-1.9:Language.Haskell.TH.Desugar.AST
                         vector-0.12.0.2:Data.Vector vector-0.12.0.2:Data.Vector.Primitive
                         vector-0.12.0.2:Data.Vector.Storable
                         vector-0.12.0.2:Data.Vector.Unboxed
                         vector-0.12.0.2:Data.Vector.Unboxed.Base
import  -/  base-4.12.0.0:Data.Type.Equality f6b04445a1c9b5058ef9dbe9a2aeb06a
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.Generics 2b3b2e72be66983021f8ad0c2edcf290
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:Unsafe.Coerce 9ab5addbda535c4a3443ba35ca948ecf
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  hashable-1.2.7.0:Data.Hashable 52de7ce057cbb2207689571a9d126e28
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 6d87087aea24143d2650f78480d954a3
import  -/  singletons-2.5.1:Data.Singletons.Internal 3383ecc7c6d9935f4cf18f0b26ad969a
import  -/  singletons-2.5.1:Data.Singletons.Single 5837439f6e678de71df027794b1e14d8
import  -/  singletons-2.5.1:Data.Singletons.TH 609315866e518f7b980581be593cd14a
2242581a46528d9da58ce752528b158c
  $fEqDefn_ ::
    GHC.Classes.Eq a => GHC.Classes.Eq (LamFunSyntax.Defn_ v a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Classes.Eq a).
                  @ (LamFunSyntax.Defn_ v a)
                  (LamFunSyntax.$fEqDefn__$c== @ a @ v v1)
                  (LamFunSyntax.$fEqDefn__$c/= @ a @ v v1) -}
2242581a46528d9da58ce752528b158c
  $fEqDefn__$c/= ::
    GHC.Classes.Eq a =>
    LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: LamFunSyntax.Defn_ v a)
                   (y :: LamFunSyntax.Defn_ v a) ->
                 case LamFunSyntax.$fEqDefn__$c== @ a @ v $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2242581a46528d9da58ce752528b158c
  $fEqDefn__$c== ::
    GHC.Classes.Eq a =>
    LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: LamFunSyntax.Defn_ v a)
                   (ds1 :: LamFunSyntax.Defn_ v a) ->
                 case ds of wild {
                   LamFunSyntax.Val_ a1 a2
                   -> case ds1 of wild1 {
                        LamFunSyntax.Val_ b1 b2
                        -> case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> LamFunSyntax.$fEqDefn__$c==1 @ a @ v $dEq a2 b2 }
                        LamFunSyntax.Rec_ ipv ipv1 ipv2 -> GHC.Types.False }
                   LamFunSyntax.Rec_ $d~ a1 a2
                   -> case ds1 of wild1 {
                        LamFunSyntax.Val_ ipv ipv1 -> GHC.Types.False
                        LamFunSyntax.Rec_ $d~1 b1 b2
                        -> case GHC.Classes.== @ a $dEq a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> LamFunSyntax.$fEqDefn__$c==1 @ a @ v $dEq a2 b2 } } }) -}
2242581a46528d9da58ce752528b158c
  $fEqDefn__$c==1 ::
    GHC.Classes.Eq a =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
2242581a46528d9da58ce752528b158c
  $fEqExpr_ ::
    GHC.Classes.Eq a => GHC.Classes.Eq (LamFunSyntax.Expr_ v a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Classes.Eq a).
                  @ (LamFunSyntax.Expr_ v a)
                  (LamFunSyntax.$fEqDefn__$c==1 @ a @ v v1)
                  (LamFunSyntax.$fEqExpr__$c/= @ a @ v v1) -}
2242581a46528d9da58ce752528b158c
  $fEqExpr__$c/= ::
    GHC.Classes.Eq a =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fEqDefn__$c==1 @ a @ v $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fEqProgram_ ::
    GHC.Classes.Eq a => GHC.Classes.Eq (LamFunSyntax.Program_ v a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Classes.Eq a).
                  @ (LamFunSyntax.Program_ v a)
                  (LamFunSyntax.$fEqProgram__$c== @ a @ v v1)
                  (LamFunSyntax.$fEqProgram__$c/= @ a @ v v1) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fEqProgram__$c/= ::
    GHC.Classes.Eq a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>, Inline: (sat-args=2),
     Unfolding: InlineRule (3, False, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dEq :: GHC.Classes.Eq a)
                   (x :: LamFunSyntax.Program_ v a)
                   (y :: LamFunSyntax.Program_ v a) ->
                 case LamFunSyntax.$fEqProgram__$c== @ a @ v $dEq x y of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fEqProgram__$c== ::
    GHC.Classes.Eq a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dEq :: GHC.Classes.Eq a)
                   (ds :: LamFunSyntax.Program_ v a)
                   (ds1 :: LamFunSyntax.Program_ v a) ->
                 case ds of wild {
                   LamFunSyntax.Calculate_ a1
                   -> case ds1 of wild1 {
                        LamFunSyntax.Calculate_ b1
                        -> LamFunSyntax.$fEqDefn__$c==1 @ a @ v $dEq a1 b1
                        LamFunSyntax.Define_ ipv ipv1 -> GHC.Types.False }
                   LamFunSyntax.Define_ $d~ a1
                   -> case ds1 of wild1 {
                        LamFunSyntax.Calculate_ ipv -> GHC.Types.False
                        LamFunSyntax.Define_ $d~1 b1
                        -> LamFunSyntax.$fEqDefn__$c== @ a @ v $dEq a1 b1 } }) -}
30fcd6637505d1a5ef24282cc7f41972
  $fEqVersion :: GHC.Classes.Eq LamFunSyntax.Version
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunSyntax.Version
                  LamFunSyntax.$fEqVersion_$c==
                  LamFunSyntax.$fEqVersion_$c/= -}
30fcd6637505d1a5ef24282cc7f41972
  $fEqVersion_$c/= ::
    LamFunSyntax.Version -> LamFunSyntax.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: LamFunSyntax.Version) (y :: LamFunSyntax.Version) ->
                 case x of wild {
                   LamFunSyntax.LamCBN
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunSyntax.LamCBN -> GHC.Types.False }
                   LamFunSyntax.LamCBV
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunSyntax.LamCBV -> GHC.Types.False }
                   LamFunSyntax.LamNat
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunSyntax.LamNat -> GHC.Types.False }
                   LamFunSyntax.LamRec
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunSyntax.LamRec -> GHC.Types.False }
                   LamFunSyntax.LamMem
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True LamFunSyntax.LamMem -> GHC.Types.False }
                   LamFunSyntax.LamArray
                   -> case y of wild1 {
                        DEFAULT -> GHC.Types.True
                        LamFunSyntax.LamArray -> GHC.Types.False } }) -}
30fcd6637505d1a5ef24282cc7f41972
  $fEqVersion_$c== ::
    LamFunSyntax.Version -> LamFunSyntax.Version -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: LamFunSyntax.Version)
                   (ds1 :: LamFunSyntax.Version) ->
                 case ds of wild {
                   LamFunSyntax.LamCBN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunSyntax.LamCBN -> GHC.Types.True }
                   LamFunSyntax.LamCBV
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunSyntax.LamCBV -> GHC.Types.True }
                   LamFunSyntax.LamNat
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunSyntax.LamNat -> GHC.Types.True }
                   LamFunSyntax.LamRec
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunSyntax.LamRec -> GHC.Types.True }
                   LamFunSyntax.LamMem
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False LamFunSyntax.LamMem -> GHC.Types.True }
                   LamFunSyntax.LamArray
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        LamFunSyntax.LamArray -> GHC.Types.True } }) -}
2242581a46528d9da58ce752528b158c
  $fFunctorDefn_ :: GHC.Base.Functor (LamFunSyntax.Defn_ v)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ v :: LamFunSyntax.Version.
                  @ (LamFunSyntax.Defn_ v)
                  (LamFunSyntax.$fFunctorDefn__$cfmap @ v)
                  (LamFunSyntax.$fFunctorDefn__$c<$ @ v) -}
2242581a46528d9da58ce752528b158c
  $fFunctorDefn__$c<$ ::
    a -> LamFunSyntax.Defn_ v b -> LamFunSyntax.Defn_ v a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ v :: LamFunSyntax.Version
                   @ a
                   @ b
                   (z :: a)
                   (ds :: LamFunSyntax.Defn_ v b) ->
                 case ds of wild {
                   LamFunSyntax.Val_ a1 a2
                   -> LamFunSyntax.Val_
                        @ v
                        @ a
                        z
                        (LamFunSyntax.$fFunctorDefn__$c<$1 @ v @ a @ b z a2)
                   LamFunSyntax.Rec_ $d~ a1 a2
                   -> case GHC.Types.heq_sel
                             @ GHC.Types.Bool
                             @ GHC.Types.Bool
                             @ ('LamFunSyntax.LamRec LamFunSyntax.<: v)
                             @ 'GHC.Types.True
                             $d~
                               `cast`
                             (Data.Type.Equality.N:~[0] <GHC.Types.Bool>_N <'LamFunSyntax.LamRec
                                                                            LamFunSyntax.<: v>_N <'GHC.Types.True>_N) of co { DEFAULT ->
                      LamFunSyntax.Rec_
                        @ v
                        @ a
                        $d~
                        z
                        (LamFunSyntax.$fFunctorDefn__$c<$1 @ v @ a @ b z a2) } }) -}
2242581a46528d9da58ce752528b158c
  $fFunctorDefn__$c<$1 ::
    a -> LamFunSyntax.Expr_ v b -> LamFunSyntax.Expr_ v a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U> -}
2242581a46528d9da58ce752528b158c
  $fFunctorDefn__$cfmap ::
    (a -> b) -> LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ v :: LamFunSyntax.Version
                   @ a
                   @ b
                   (f6 :: a -> b)
                   (ds :: LamFunSyntax.Defn_ v a) ->
                 case ds of wild {
                   LamFunSyntax.Val_ a1 a2
                   -> LamFunSyntax.Val_
                        @ v
                        @ b
                        (f6 a1)
                        (LamFunSyntax.$fFunctorDefn__$cfmap1 @ v @ a @ b f6 a2)
                   LamFunSyntax.Rec_ $d~ a1 a2
                   -> case GHC.Types.heq_sel
                             @ GHC.Types.Bool
                             @ GHC.Types.Bool
                             @ ('LamFunSyntax.LamRec LamFunSyntax.<: v)
                             @ 'GHC.Types.True
                             $d~
                               `cast`
                             (Data.Type.Equality.N:~[0] <GHC.Types.Bool>_N <'LamFunSyntax.LamRec
                                                                            LamFunSyntax.<: v>_N <'GHC.Types.True>_N) of co { DEFAULT ->
                      LamFunSyntax.Rec_
                        @ v
                        @ b
                        $d~
                        (f6 a1)
                        (LamFunSyntax.$fFunctorDefn__$cfmap1 @ v @ a @ b f6 a2) } }) -}
2242581a46528d9da58ce752528b158c
  $fFunctorDefn__$cfmap1 ::
    (a -> b) -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U> -}
2242581a46528d9da58ce752528b158c
  $fFunctorExpr_ :: GHC.Base.Functor (LamFunSyntax.Expr_ v)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ v :: LamFunSyntax.Version.
                  @ (LamFunSyntax.Expr_ v)
                  (LamFunSyntax.$fFunctorDefn__$cfmap1 @ v)
                  (LamFunSyntax.$fFunctorDefn__$c<$1 @ v) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fFunctorProgram_ :: GHC.Base.Functor (LamFunSyntax.Program_ v)
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ v :: LamFunSyntax.Version.
                  @ (LamFunSyntax.Program_ v)
                  (LamFunSyntax.$fFunctorProgram__$cfmap @ v)
                  (LamFunSyntax.$fFunctorProgram__$c<$ @ v) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fFunctorProgram__$c<$ ::
    a -> LamFunSyntax.Program_ v b -> LamFunSyntax.Program_ v a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ v :: LamFunSyntax.Version
                   @ a
                   @ b
                   (z :: a)
                   (ds :: LamFunSyntax.Program_ v b) ->
                 case ds of wild {
                   LamFunSyntax.Calculate_ a1
                   -> LamFunSyntax.Calculate_
                        @ v
                        @ a
                        (LamFunSyntax.$fFunctorDefn__$c<$1 @ v @ a @ b z a1)
                   LamFunSyntax.Define_ $d~ a1
                   -> case GHC.Types.heq_sel
                             @ GHC.Types.Bool
                             @ GHC.Types.Bool
                             @ ('LamFunSyntax.LamNat LamFunSyntax.<: v)
                             @ 'GHC.Types.True
                             $d~
                               `cast`
                             (Data.Type.Equality.N:~[0] <GHC.Types.Bool>_N <'LamFunSyntax.LamNat
                                                                            LamFunSyntax.<: v>_N <'GHC.Types.True>_N) of co { DEFAULT ->
                      LamFunSyntax.Define_
                        @ v
                        @ a
                        $d~
                        (LamFunSyntax.$fFunctorDefn__$c<$ @ v @ a @ b z a1) } }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fFunctorProgram__$cfmap ::
    (a -> b) -> LamFunSyntax.Program_ v a -> LamFunSyntax.Program_ v b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ v :: LamFunSyntax.Version
                   @ a
                   @ b
                   (f6 :: a -> b)
                   (ds :: LamFunSyntax.Program_ v a) ->
                 case ds of wild {
                   LamFunSyntax.Calculate_ a1
                   -> LamFunSyntax.Calculate_
                        @ v
                        @ b
                        (LamFunSyntax.$fFunctorDefn__$cfmap1 @ v @ a @ b f6 a1)
                   LamFunSyntax.Define_ $d~ a1
                   -> case GHC.Types.heq_sel
                             @ GHC.Types.Bool
                             @ GHC.Types.Bool
                             @ ('LamFunSyntax.LamNat LamFunSyntax.<: v)
                             @ 'GHC.Types.True
                             $d~
                               `cast`
                             (Data.Type.Equality.N:~[0] <GHC.Types.Bool>_N <'LamFunSyntax.LamNat
                                                                            LamFunSyntax.<: v>_N <'GHC.Types.True>_N) of co { DEFAULT ->
                      LamFunSyntax.Define_
                        @ v
                        @ b
                        $d~
                        (LamFunSyntax.$fFunctorDefn__$cfmap @ v @ a @ b f6 a1) } }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn_ ::
    GHC.Classes.Ord a => GHC.Classes.Ord (LamFunSyntax.Defn_ v a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Classes.Ord a).
                  @ (LamFunSyntax.Defn_ v a)
                  (LamFunSyntax.$fOrdDefn__$cp1Ord @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$ccompare1 @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$c< @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$c<= @ a @ v v1)
                  (\ (a1 :: LamFunSyntax.Defn_ v a) (b :: LamFunSyntax.Defn_ v a) ->
                   LamFunSyntax.$fOrdDefn__$c< @ a @ v v1 b a1)
                  (LamFunSyntax.$fOrdDefn__$c>= @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$cmax @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$cmin @ a @ v v1) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$c< ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Defn_ v a)
                   (b :: LamFunSyntax.Defn_ v a) ->
                 case a1 of wild {
                   LamFunSyntax.Val_ a2 a3
                   -> case b of wild1 {
                        LamFunSyntax.Val_ b1 b2
                        -> case GHC.Classes.compare @ a $dOrd a2 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ -> LamFunSyntax.$fOrdDefn__$c<1 @ a @ v $dOrd a3 b2
                             GHC.Types.GT -> GHC.Types.False }
                        LamFunSyntax.Rec_ ipv ipv1 ipv2 -> GHC.Types.True }
                   LamFunSyntax.Rec_ $d~ a2 a3
                   -> case b of wild1 {
                        LamFunSyntax.Val_ ipv ipv1 -> GHC.Types.False
                        LamFunSyntax.Rec_ $d~1 b1 b2
                        -> case GHC.Classes.compare @ a $dOrd a2 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ -> LamFunSyntax.$fOrdDefn__$c<1 @ a @ v $dOrd a3 b2
                             GHC.Types.GT -> GHC.Types.False } } }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$c<1 ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$c<= ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Defn_ v a)
                   (b :: LamFunSyntax.Defn_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$c< @ a @ v $dOrd b a1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$c>= ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Defn_ v a)
                   (b :: LamFunSyntax.Defn_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$c< @ a @ v $dOrd a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$ccompare ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> GHC.Types.Ordering
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)> -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$ccompare1 ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Defn_ v a
    -> LamFunSyntax.Defn_ v a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Defn_ v a)
                   (b :: LamFunSyntax.Defn_ v a) ->
                 case a1 of wild {
                   LamFunSyntax.Val_ a2 a3
                   -> case b of wild1 {
                        LamFunSyntax.Val_ b1 b2
                        -> case GHC.Classes.compare @ a $dOrd a2 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd a3 b2
                             GHC.Types.GT -> GHC.Types.GT }
                        LamFunSyntax.Rec_ ipv ipv1 ipv2 -> GHC.Types.LT }
                   LamFunSyntax.Rec_ $d~ a2 a3
                   -> case b of wild1 {
                        LamFunSyntax.Val_ ipv ipv1 -> GHC.Types.GT
                        LamFunSyntax.Rec_ $d~1 b1 b2
                        -> case GHC.Classes.compare @ a $dOrd a2 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd a3 b2
                             GHC.Types.GT -> GHC.Types.GT } } }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$cmax ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Defn_ v a
    -> LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Defn_ v a)
                   (y :: LamFunSyntax.Defn_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$c< @ a @ v $dOrd y x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$cmin ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Defn_ v a
    -> LamFunSyntax.Defn_ v a -> LamFunSyntax.Defn_ v a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Defn_ v a)
                   (y :: LamFunSyntax.Defn_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$c< @ a @ v $dOrd y x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
2242581a46528d9da58ce752528b158c
  $fOrdDefn__$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (LamFunSyntax.Defn_ v a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ v :: LamFunSyntax.Version ($dOrd :: GHC.Classes.Ord a) ->
                 LamFunSyntax.$fEqDefn_ @ a @ v (GHC.Classes.$p1Ord @ a $dOrd)) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr_ ::
    GHC.Classes.Ord a => GHC.Classes.Ord (LamFunSyntax.Expr_ v a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Classes.Ord a).
                  @ (LamFunSyntax.Expr_ v a)
                  (LamFunSyntax.$fOrdExpr__$cp1Ord @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$ccompare @ a @ v v1)
                  (LamFunSyntax.$fOrdDefn__$c<1 @ a @ v v1)
                  (LamFunSyntax.$fOrdExpr__$c<= @ a @ v v1)
                  (LamFunSyntax.$fOrdExpr__$c> @ a @ v v1)
                  (LamFunSyntax.$fOrdExpr__$c>= @ a @ v v1)
                  (LamFunSyntax.$fOrdExpr__$cmax @ a @ v v1)
                  (LamFunSyntax.$fOrdExpr__$cmin @ a @ v v1) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr__$c<= ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr__$c> ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd x y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr__$c>= ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd x y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr__$cmax ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd x y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr__$cmin ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Expr_ v a)
                   (y :: LamFunSyntax.Expr_ v a) ->
                 case LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd x y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
2242581a46528d9da58ce752528b158c
  $fOrdExpr__$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (LamFunSyntax.Expr_ v a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ v :: LamFunSyntax.Version ($dOrd :: GHC.Classes.Ord a) ->
                 LamFunSyntax.$fEqExpr_ @ a @ v (GHC.Classes.$p1Ord @ a $dOrd)) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram_ ::
    GHC.Classes.Ord a => GHC.Classes.Ord (LamFunSyntax.Program_ v a)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Classes.Ord a).
                  @ (LamFunSyntax.Program_ v a)
                  (LamFunSyntax.$fOrdProgram__$cp1Ord @ a @ v v1)
                  (LamFunSyntax.$fOrdProgram__$ccompare @ a @ v v1)
                  (LamFunSyntax.$fOrdProgram__$c< @ a @ v v1)
                  (LamFunSyntax.$fOrdProgram__$c<= @ a @ v v1)
                  (\ (a1 :: LamFunSyntax.Program_ v a)
                     (b :: LamFunSyntax.Program_ v a) ->
                   LamFunSyntax.$fOrdProgram__$c< @ a @ v v1 b a1)
                  (LamFunSyntax.$fOrdProgram__$c>= @ a @ v v1)
                  (LamFunSyntax.$fOrdProgram__$cmax @ a @ v v1)
                  (LamFunSyntax.$fOrdProgram__$cmin @ a @ v v1) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$c< ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Program_ v a)
                   (b :: LamFunSyntax.Program_ v a) ->
                 case a1 of wild {
                   LamFunSyntax.Calculate_ a2
                   -> case b of wild1 {
                        LamFunSyntax.Calculate_ b1
                        -> LamFunSyntax.$fOrdDefn__$c<1 @ a @ v $dOrd a2 b1
                        LamFunSyntax.Define_ ipv ipv1 -> GHC.Types.True }
                   LamFunSyntax.Define_ $d~ a2
                   -> case b of wild1 {
                        LamFunSyntax.Calculate_ ipv -> GHC.Types.False
                        LamFunSyntax.Define_ $d~1 b1
                        -> LamFunSyntax.$fOrdDefn__$c< @ a @ v $dOrd a2 b1 } }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$c<= ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Program_ v a)
                   (b :: LamFunSyntax.Program_ v a) ->
                 case LamFunSyntax.$fOrdProgram__$c< @ a @ v $dOrd b a1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$c>= ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Program_ v a)
                   (b :: LamFunSyntax.Program_ v a) ->
                 case LamFunSyntax.$fOrdProgram__$c< @ a @ v $dOrd a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$ccompare ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> GHC.Types.Ordering
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (a1 :: LamFunSyntax.Program_ v a)
                   (b :: LamFunSyntax.Program_ v a) ->
                 case a1 of wild {
                   LamFunSyntax.Calculate_ a2
                   -> case b of wild1 {
                        LamFunSyntax.Calculate_ b1
                        -> LamFunSyntax.$fOrdDefn__$ccompare @ a @ v $dOrd a2 b1
                        LamFunSyntax.Define_ ipv ipv1 -> GHC.Types.LT }
                   LamFunSyntax.Define_ $d~ a2
                   -> case b of wild1 {
                        LamFunSyntax.Calculate_ ipv -> GHC.Types.GT
                        LamFunSyntax.Define_ $d~1 b1
                        -> LamFunSyntax.$fOrdDefn__$ccompare1 @ a @ v $dOrd a2 b1 } }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$cmax ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> LamFunSyntax.Program_ v a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Program_ v a)
                   (y :: LamFunSyntax.Program_ v a) ->
                 case LamFunSyntax.$fOrdProgram__$c< @ a @ v $dOrd y x of wild {
                   GHC.Types.False -> y GHC.Types.True -> x }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$cmin ::
    GHC.Classes.Ord a =>
    LamFunSyntax.Program_ v a
    -> LamFunSyntax.Program_ v a -> LamFunSyntax.Program_ v a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(C1(U)),A,A,A,A,A,A)><S,U><S,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dOrd :: GHC.Classes.Ord a)
                   (x :: LamFunSyntax.Program_ v a)
                   (y :: LamFunSyntax.Program_ v a) ->
                 case LamFunSyntax.$fOrdProgram__$c< @ a @ v $dOrd y x of wild {
                   GHC.Types.False -> x GHC.Types.True -> y }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fOrdProgram__$cp1Ord ::
    GHC.Classes.Ord a => GHC.Classes.Eq (LamFunSyntax.Program_ v a)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ v :: LamFunSyntax.Version ($dOrd :: GHC.Classes.Ord a) ->
                 LamFunSyntax.$fEqProgram_
                   @ a
                   @ v
                   (GHC.Classes.$p1Ord @ a $dOrd)) -}
2242581a46528d9da58ce752528b158c
  $fShowDefn_ ::
    GHC.Show.Show a => GHC.Show.Show (LamFunSyntax.Defn_ v a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Show.Show a).
                  @ (LamFunSyntax.Defn_ v a)
                  (LamFunSyntax.$fShowDefn__$cshowsPrec @ a @ v v1)
                  (LamFunSyntax.$fShowDefn__$cshow @ a @ v v1)
                  (LamFunSyntax.$fShowDefn__$cshowList @ a @ v v1) -}
da9201f5a1e4f0b7a9b2c919e72cb26e
  $fShowDefn_1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1d7289584bc452fb5fb97b0997c4db94
  $fShowDefn_2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Rec_ "#) -}
bb1a536e934526189de762d0e8f03753
  $fShowDefn_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Val_ "#) -}
c1a7853cc56e71e031565df216c69ab3
  $fShowDefn_4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
2242581a46528d9da58ce752528b158c
  $fShowDefn__$cshow ::
    GHC.Show.Show a => LamFunSyntax.Defn_ v a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dShow :: GHC.Show.Show a)
                   (x :: LamFunSyntax.Defn_ v a) ->
                 LamFunSyntax.$fShowDefn__$cshowsPrec
                   @ a
                   @ v
                   $dShow
                   LamFunSyntax.$fShowDefn_1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2242581a46528d9da58ce752528b158c
  $fShowDefn__$cshowList ::
    GHC.Show.Show a => [LamFunSyntax.Defn_ v a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [LamFunSyntax.Defn_ v a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LamFunSyntax.Defn_ v a)
                   (LamFunSyntax.$fShowDefn__$cshowsPrec
                      @ a
                      @ v
                      $dShow
                      LamFunSyntax.$fShowDefn_1)
                   ls
                   s) -}
2242581a46528d9da58ce752528b158c
  $fShowDefn__$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> LamFunSyntax.Defn_ v a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: LamFunSyntax.Defn_ v a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 LamFunSyntax.$w$cshowsPrec @ a @ v w ww1 w2 }) -}
2242581a46528d9da58ce752528b158c
  $fShowDefn__$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Types.Int -> LamFunSyntax.Expr_ v a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><L,1*U(U)><S,1*U> -}
2242581a46528d9da58ce752528b158c
  $fShowExpr_ ::
    GHC.Show.Show a => GHC.Show.Show (LamFunSyntax.Expr_ v a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Show.Show a).
                  @ (LamFunSyntax.Expr_ v a)
                  (LamFunSyntax.$fShowDefn__$cshowsPrec1 @ a @ v v1)
                  (LamFunSyntax.$fShowExpr__$cshow @ a @ v v1)
                  (LamFunSyntax.$fShowExpr__$cshowList @ a @ v v1) -}
2242581a46528d9da58ce752528b158c
  $fShowExpr__$cshow ::
    GHC.Show.Show a => LamFunSyntax.Expr_ v a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dShow :: GHC.Show.Show a)
                   (x :: LamFunSyntax.Expr_ v a) ->
                 LamFunSyntax.$fShowDefn__$cshowsPrec1
                   @ a
                   @ v
                   $dShow
                   LamFunSyntax.$fShowDefn_1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2242581a46528d9da58ce752528b158c
  $fShowExpr__$cshowList ::
    GHC.Show.Show a => [LamFunSyntax.Expr_ v a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [LamFunSyntax.Expr_ v a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LamFunSyntax.Expr_ v a)
                   (LamFunSyntax.$fShowDefn__$cshowsPrec1
                      @ a
                      @ v
                      $dShow
                      LamFunSyntax.$fShowDefn_1)
                   ls
                   s) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fShowProgram_ ::
    GHC.Show.Show a => GHC.Show.Show (LamFunSyntax.Program_ v a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a
                      @ v :: LamFunSyntax.Version
                      (v1 :: GHC.Show.Show a).
                  @ (LamFunSyntax.Program_ v a)
                  (LamFunSyntax.$fShowProgram__$cshowsPrec @ a @ v v1)
                  (LamFunSyntax.$fShowProgram__$cshow @ a @ v v1)
                  (LamFunSyntax.$fShowProgram__$cshowList @ a @ v v1) -}
45999cadeb66df573e7e0cd6619d0806
  $fShowProgram_1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowProgram_2) -}
06b7033eee508e2f28bb4e1044cfc61a
  $fShowProgram_2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Define_ "#) -}
523ab4c00b3c2378bb8c5f565787ce5e
  $fShowProgram_3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowProgram_4) -}
1b061f396cc4a5179f9690e3d5b00935
  $fShowProgram_4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Calculate_ "#) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fShowProgram__$cshow ::
    GHC.Show.Show a => LamFunSyntax.Program_ v a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dShow :: GHC.Show.Show a)
                   (x :: LamFunSyntax.Program_ v a) ->
                 case x of wild {
                   LamFunSyntax.Calculate_ b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        LamFunSyntax.$fShowProgram_3
                        (LamFunSyntax.$fShowDefn__$cshowsPrec1
                           @ a
                           @ v
                           $dShow
                           LamFunSyntax.$fShowDefn_4
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   LamFunSyntax.Define_ $d~ b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        LamFunSyntax.$fShowProgram_1
                        (LamFunSyntax.$w$cshowsPrec
                           @ a
                           @ v
                           $dShow
                           11#
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fShowProgram__$cshowList ::
    GHC.Show.Show a => [LamFunSyntax.Program_ v a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [LamFunSyntax.Program_ v a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (LamFunSyntax.Program_ v a)
                   (LamFunSyntax.$fShowProgram__$cshowsPrec
                      @ a
                      @ v
                      $dShow
                      LamFunSyntax.$fShowDefn_1)
                   ls
                   s) -}
8f11ad5d9dc6600f48b5495879bef02f
  $fShowProgram__$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> LamFunSyntax.Program_ v a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C(U))),A,A)><S(S),1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ v :: LamFunSyntax.Version
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: LamFunSyntax.Program_ v a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 LamFunSyntax.$w$cshowsPrec1 @ a @ v w ww1 w2 }) -}
30fcd6637505d1a5ef24282cc7f41972
  $fShowVersion :: GHC.Show.Show LamFunSyntax.Version
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunSyntax.Version
                  LamFunSyntax.$fShowVersion_$cshowsPrec
                  LamFunSyntax.$fShowVersion_$cshow
                  LamFunSyntax.$fShowVersion_$cshowList -}
ec57d529b4a4e2a0fbd43431b2247e45
  $fShowVersion1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowVersion2) -}
a1ae27de8b439bed9253c7dbe4e39029
  $fShowVersion10 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamCBV"#) -}
47e7ee45e12d7342c31fda62a8f1a091
  $fShowVersion11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowVersion12) -}
36d6da2ee8d1f6d3a9c1cf4ab10a245e
  $fShowVersion12 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamCBN"#) -}
9b08ff006df6489cc5f5b537ba4f5903
  $fShowVersion2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamArray"#) -}
aba625f8b364100ff4c0866df9f1d0d4
  $fShowVersion3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowVersion4) -}
17df2b83f4eab79cbad13f5ea976c9ee
  $fShowVersion4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamMem"#) -}
dc805a815b3876cbee22677379114104
  $fShowVersion5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowVersion6) -}
f44d677bc3113ae94b233ef697aaf6ac
  $fShowVersion6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamRec"#) -}
32c8bfd68f249e39b39d3724de27b5a9
  $fShowVersion7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowVersion8) -}
e61f3ebdddecae9fed7074a39c7a9567
  $fShowVersion8 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamNat"#) -}
50cde3b4ba0b0eafee23722c4e5bb2bd
  $fShowVersion9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   LamFunSyntax.$fShowVersion10) -}
30fcd6637505d1a5ef24282cc7f41972
  $fShowVersion_$cshow :: LamFunSyntax.Version -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: LamFunSyntax.Version) ->
                 case x of wild {
                   LamFunSyntax.LamCBN -> LamFunSyntax.$fShowVersion11
                   LamFunSyntax.LamCBV -> LamFunSyntax.$fShowVersion9
                   LamFunSyntax.LamNat -> LamFunSyntax.$fShowVersion7
                   LamFunSyntax.LamRec -> LamFunSyntax.$fShowVersion5
                   LamFunSyntax.LamMem -> LamFunSyntax.$fShowVersion3
                   LamFunSyntax.LamArray -> LamFunSyntax.$fShowVersion1 }) -}
30fcd6637505d1a5ef24282cc7f41972
  $fShowVersion_$cshowList ::
    [LamFunSyntax.Version] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [LamFunSyntax.Version]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ LamFunSyntax.Version
                   LamFunSyntax.$w$cshowsPrec2
                   ls
                   s) -}
30fcd6637505d1a5ef24282cc7f41972
  $fShowVersion_$cshowsPrec ::
    GHC.Types.Int -> LamFunSyntax.Version -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: LamFunSyntax.Version)
                   (w2 :: GHC.Base.String) ->
                 LamFunSyntax.$w$cshowsPrec2 w1 w2) -}
7997788670030b5c821121b098b34696
  $fSingIVersionLamArray ::
    Data.Singletons.Internal.SingI 'LamFunSyntax.LamArray
  DFunId
  {- Strictness: m6, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                LamFunSyntax.$WSLamArray
                  `cast`
                (Sym (Data.Singletons.Internal.N:SingI[0]) <LamFunSyntax.Version>_N <'LamFunSyntax.LamArray>_N) -}
5382f22c7ff76d9291b715e4bc9721e6
  $fSingIVersionLamCBN ::
    Data.Singletons.Internal.SingI 'LamFunSyntax.LamCBN
  DFunId
  {- Strictness: m1, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                LamFunSyntax.$WSLamCBN
                  `cast`
                (Sym (Data.Singletons.Internal.N:SingI[0]) <LamFunSyntax.Version>_N <'LamFunSyntax.LamCBN>_N) -}
5ae48185568f7b455561d6ea11e09b44
  $fSingIVersionLamCBV ::
    Data.Singletons.Internal.SingI 'LamFunSyntax.LamCBV
  DFunId
  {- Strictness: m2, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                LamFunSyntax.$WSLamCBV
                  `cast`
                (Sym (Data.Singletons.Internal.N:SingI[0]) <LamFunSyntax.Version>_N <'LamFunSyntax.LamCBV>_N) -}
2de4fbc4187b5b2b12b0892ddb1274da
  $fSingIVersionLamMem ::
    Data.Singletons.Internal.SingI 'LamFunSyntax.LamMem
  DFunId
  {- Strictness: m5, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                LamFunSyntax.$WSLamMem
                  `cast`
                (Sym (Data.Singletons.Internal.N:SingI[0]) <LamFunSyntax.Version>_N <'LamFunSyntax.LamMem>_N) -}
d69ea860e302101d6261b95f6f19b9a7
  $fSingIVersionLamNat ::
    Data.Singletons.Internal.SingI 'LamFunSyntax.LamNat
  DFunId
  {- Strictness: m3, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                LamFunSyntax.$WSLamNat
                  `cast`
                (Sym (Data.Singletons.Internal.N:SingI[0]) <LamFunSyntax.Version>_N <'LamFunSyntax.LamNat>_N) -}
30f11277d52aed24b2b0f1ab834b3626
  $fSingIVersionLamRec ::
    Data.Singletons.Internal.SingI 'LamFunSyntax.LamRec
  DFunId
  {- Strictness: m4, Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                LamFunSyntax.$WSLamRec
                  `cast`
                (Sym (Data.Singletons.Internal.N:SingI[0]) <LamFunSyntax.Version>_N <'LamFunSyntax.LamRec>_N) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion ::
    Data.Singletons.Internal.SingKind LamFunSyntax.Version
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ LamFunSyntax.Version
                  LamFunSyntax.$fSingKindVersion_$cfromSing
                  LamFunSyntax.$fSingKindVersion_$ctoSing -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion1 ::
    Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- HasNoCafRefs,
     Unfolding: (Data.Singletons.Internal.SomeSing
                   @ LamFunSyntax.Version
                   @ 'LamFunSyntax.LamArray
                   LamFunSyntax.$WSLamArray) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion2 ::
    Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- HasNoCafRefs,
     Unfolding: (Data.Singletons.Internal.SomeSing
                   @ LamFunSyntax.Version
                   @ 'LamFunSyntax.LamMem
                   LamFunSyntax.$WSLamMem) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion3 ::
    Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- HasNoCafRefs,
     Unfolding: (Data.Singletons.Internal.SomeSing
                   @ LamFunSyntax.Version
                   @ 'LamFunSyntax.LamRec
                   LamFunSyntax.$WSLamRec) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion4 ::
    Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- HasNoCafRefs,
     Unfolding: (Data.Singletons.Internal.SomeSing
                   @ LamFunSyntax.Version
                   @ 'LamFunSyntax.LamNat
                   LamFunSyntax.$WSLamNat) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion5 ::
    Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- HasNoCafRefs,
     Unfolding: (Data.Singletons.Internal.SomeSing
                   @ LamFunSyntax.Version
                   @ 'LamFunSyntax.LamCBV
                   LamFunSyntax.$WSLamCBV) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion6 ::
    Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- HasNoCafRefs,
     Unfolding: (Data.Singletons.Internal.SomeSing
                   @ LamFunSyntax.Version
                   @ 'LamFunSyntax.LamCBN
                   LamFunSyntax.$WSLamCBN) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion_$cfromSing ::
    Data.Singletons.Internal.Sing a
    -> Data.Singletons.Internal.Demote LamFunSyntax.Version
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a :: LamFunSyntax.Version
                   (ds :: Data.Singletons.Internal.Sing a) ->
                 case ds `cast` (LamFunSyntax.D:R:SingVersion0[0] <a>_N) of wild {
                   LamFunSyntax.SLamCBN co
                   -> LamFunSyntax.LamCBN
                        `cast`
                      (Sub (Sym (LamFunSyntax.D:R:DemoteVersion[0])))
                   LamFunSyntax.SLamCBV co
                   -> LamFunSyntax.LamCBV
                        `cast`
                      (Sub (Sym (LamFunSyntax.D:R:DemoteVersion[0])))
                   LamFunSyntax.SLamNat co
                   -> LamFunSyntax.LamNat
                        `cast`
                      (Sub (Sym (LamFunSyntax.D:R:DemoteVersion[0])))
                   LamFunSyntax.SLamRec co
                   -> LamFunSyntax.LamRec
                        `cast`
                      (Sub (Sym (LamFunSyntax.D:R:DemoteVersion[0])))
                   LamFunSyntax.SLamMem co
                   -> LamFunSyntax.LamMem
                        `cast`
                      (Sub (Sym (LamFunSyntax.D:R:DemoteVersion[0])))
                   LamFunSyntax.SLamArray co
                   -> LamFunSyntax.LamArray
                        `cast`
                      (Sub (Sym (LamFunSyntax.D:R:DemoteVersion[0]))) }) -}
30fcd6637505d1a5ef24282cc7f41972
  $fSingKindVersion_$ctoSing ::
    Data.Singletons.Internal.Demote LamFunSyntax.Version
    -> Data.Singletons.Internal.SomeSing LamFunSyntax.Version
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Data.Singletons.Internal.Demote LamFunSyntax.Version) ->
                 case ds `cast` (Sub (LamFunSyntax.D:R:DemoteVersion[0])) of wild {
                   LamFunSyntax.LamCBN -> LamFunSyntax.$fSingKindVersion6
                   LamFunSyntax.LamCBV -> LamFunSyntax.$fSingKindVersion5
                   LamFunSyntax.LamNat -> LamFunSyntax.$fSingKindVersion4
                   LamFunSyntax.LamRec -> LamFunSyntax.$fSingKindVersion3
                   LamFunSyntax.LamMem -> LamFunSyntax.$fSingKindVersion2
                   LamFunSyntax.LamArray -> LamFunSyntax.$fSingKindVersion1 }) -}
beefa537802b2e6afe0811a1a6881e0e
  $tc'App_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9155047428521778339##
                   13672407711246011123##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'App_2
                   2#
                   LamFunSyntax.$tc'App_1) -}
63b96971197acef368925070805ab204
  $tc'App_1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a05d39f401dd207fb8db4ff547da3d09
  $tc'App_2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'App_3) -}
261c60a2629b87bae83704aad372b56f
  $tc'App_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'App_"#) -}
b7edb211dab550a12ac3dd1134afe945
  $tc'Calculate_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5276217441658856644##
                   17129929869562006060##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'Calculate_2
                   2#
                   LamFunSyntax.$tc'Calculate_1) -}
8304bd1037f0de6a278132d2a54cb31c
  $tc'Calculate_1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
d8928a56919a4e389c75ffdc385a2bad
  $tc'Calculate_2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'Calculate_3) -}
b43ad4f6f009c8b889788e57711f0a4f
  $tc'Calculate_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Calculate_"#) -}
eeb5f0916566d61ba44aad97ee153916
  $tc'LamArray :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8415842227212030396##
                   14098568798119071953##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'LamArray2
                   0#
                   LamFunSyntax.$tc'LamArray1) -}
a7ba8abbd922debb21d6efd60fc267ee
  $tc'LamArray1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
3e3d9e1a71cd9e29c209a165942e3843
  $tc'LamArray2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'LamArray3) -}
f266f415bf2bfb1b6defae066ecea222
  $tc'LamArray3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LamArray"#) -}
49a91f0d9b754f06889d49e7a79e4c2b
  $tc'LamCBN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5950448277144970799##
                   8802678358616415632##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'LamCBN1
                   0#
                   LamFunSyntax.$tc'LamArray1) -}
969c34152999fad34f612a16132320a1
  $tc'LamCBN1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'LamCBN2) -}
97cb270aaab4b018d11a4fccf7607593
  $tc'LamCBN2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LamCBN"#) -}
022d3bf33bce6067252e842bcd75d390
  $tc'LamCBV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   179658207776954691##
                   18214521709049286717##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'LamCBV1
                   0#
                   LamFunSyntax.$tc'LamArray1) -}
6d327e8accb5baa0fa84b5fed1a90256
  $tc'LamCBV1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'LamCBV2) -}
4fde3a6bf2164ad68dd61dd23bdd0ff9
  $tc'LamCBV2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LamCBV"#) -}
48e9f8e449a78d475372c876cebeba35
  $tc'LamMem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3185192469545345145##
                   7974676143103033440##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'LamMem1
                   0#
                   LamFunSyntax.$tc'LamArray1) -}
9f928b449a828b95d281364955f84490
  $tc'LamMem1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'LamMem2) -}
50aa178b5833ee04e395430d6cf4bc27
  $tc'LamMem2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LamMem"#) -}
3f4a0946b4ca9866afb59a4187c1f0af
  $tc'LamNat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12021092111539430186##
                   12351231444509545201##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'LamNat1
                   0#
                   LamFunSyntax.$tc'LamArray1) -}
ecc366980c5ab7d6e67b9fdbd54ce6cf
  $tc'LamNat1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'LamNat2) -}
eb4dd6bb64185828b09694229c1ba371
  $tc'LamNat2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LamNat"#) -}
68ccdf10c62b67cdd2f53255e2e256bf
  $tc'LamRec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15627044393805798873##
                   4951444047026653626##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'LamRec1
                   0#
                   LamFunSyntax.$tc'LamArray1) -}
cf20e6f50219242ffd749ec7c182db28
  $tc'LamRec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'LamRec2) -}
b689182cf0e96e0e99193872c0daf882
  $tc'LamRec2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'LamRec"#) -}
3b72dd870e6bf5a0eebd021fc5af9be8
  $tc'Lambda_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4024067407456241727##
                   6883272728559909191##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'Lambda_2
                   2#
                   LamFunSyntax.$tc'Lambda_1) -}
559812e3efd3fc55779c39265a9c380e
  $tc'Lambda_1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e71313c6109220685784641321674235
  $tc'Lambda_2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'Lambda_3) -}
62dc63f12f4dc6b4c674485e38cc8d91
  $tc'Lambda_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Lambda_"#) -}
2c67fbd70fc0be9d6cedb14a771c82c2
  $tc'SLamArray :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15154529497319747181##
                   1174181687929474993##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'SLamArray2
                   0#
                   LamFunSyntax.$tc'SLamArray1) -}
47561c0f47fb77847729b60449cde8f7
  $tc'SLamArray1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
3529c65829af5d5351338a7ea3afb78d
  $tc'SLamArray2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'SLamArray3) -}
73088dc93be2a062c0cb100d0985c3dc
  $tc'SLamArray3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SLamArray"#) -}
58af299943bd6d27ce806258697c5b9e
  $tc'SLamCBN :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11813837045061358826##
                   8205475296769514905##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'SLamCBN2
                   0#
                   LamFunSyntax.$tc'SLamCBN1) -}
a28277ac47e298798c0acc18e59fc100
  $tc'SLamCBN1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
3378892919364b06917504be13a12772
  $tc'SLamCBN2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'SLamCBN3) -}
304cc95d87d0e5549a779ddad9bf9bfb
  $tc'SLamCBN3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SLamCBN"#) -}
c5b832cca9f99dd48dd3a5e01d6c9fe6
  $tc'SLamCBV :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4948081652820893691##
                   16127233435548617797##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'SLamCBV2
                   0#
                   LamFunSyntax.$tc'SLamCBV1) -}
e381950ca93125acffc9909fea82199b
  $tc'SLamCBV1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
e7855c642122856ebe1634cc222c6f33
  $tc'SLamCBV2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'SLamCBV3) -}
59ed5df81479440b946d4b55f00923d4
  $tc'SLamCBV3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SLamCBV"#) -}
8f2485bb4ff2f7f175de287f54b4040e
  $tc'SLamMem :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16220672175791142734##
                   2552472467017546923##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'SLamMem2
                   0#
                   LamFunSyntax.$tc'SLamMem1) -}
50f80d83c796261475e833797053ab73
  $tc'SLamMem1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
fe4b707e27e5d8d685afffd937994c19
  $tc'SLamMem2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'SLamMem3) -}
dfc6e3ac4bdd5ec7ec9f64118af5a419
  $tc'SLamMem3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SLamMem"#) -}
d26b4cddec04ba49ffc2fc896be81af1
  $tc'SLamNat :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   369449694031943954##
                   13827604108028570792##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'SLamNat2
                   0#
                   LamFunSyntax.$tc'SLamNat1) -}
5c39abf26d233a57b4ac9896d36d150f
  $tc'SLamNat1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
abda11a2643cca5ef18c2655ad3feda2
  $tc'SLamNat2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'SLamNat3) -}
beb021948e43a11543f0c0d0685aef21
  $tc'SLamNat3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SLamNat"#) -}
f6ec51ad94505035504c6a64e924a30e
  $tc'SLamRec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11928759579825818832##
                   10186382879844775545##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'SLamRec2
                   0#
                   LamFunSyntax.$tc'SLamRec1) -}
377ad5ac0670c11b2754da977b3a664b
  $tc'SLamRec1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
eabd1e77b2d5353371a6e79898e75ec8
  $tc'SLamRec2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'SLamRec3) -}
db10a12280a1f52258753733f2db31a6
  $tc'SLamRec3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'SLamRec"#) -}
1a8670775b0fa01ee081331e77c8ee85
  $tc'Val_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12718756238948005053##
                   15910635590003323007##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'Val_2
                   2#
                   LamFunSyntax.$tc'Val_1) -}
63128f6f0230621890dade863237922d
  $tc'Val_1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ee31a1a4b544d84a87a0eb5967e83e50
  $tc'Val_2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'Val_3) -}
0477686674811704e373bd7cb6d77b1b
  $tc'Val_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Val_"#) -}
bafec1ceda4243e44c2d875869406e57
  $tc'Variable_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12537837177917530451##
                   7435966676793868195##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tc'Variable_2
                   2#
                   LamFunSyntax.$tc'Variable_1) -}
ca846758e1fe0b92a5d9e329d3847c44
  $tc'Variable_1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
e9aedeffa9bc92cb2a5b9b86472c4e5c
  $tc'Variable_2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tc'Variable_3) -}
7d45d0b44c9ca46ac2a7f05081eff546
  $tc'Variable_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Variable_"#) -}
126bb8a5de29459c0ff0da5a058fa47f
  $tcDefn_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13288839546347249078##
                   12144862120816513345##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tcDefn_2
                   0#
                   LamFunSyntax.$tcDefn_1) -}
10dba9b1c785b3658489833c75ffe024
  $tcDefn_1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
32054e7665450fac9d31abf86dcfb29d
  $tcDefn_2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tcDefn_3) -}
b956b18cd7b481a62a20fad4f7040e83
  $tcDefn_3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Defn_"#) -}
78fa1d6f21ee2d15938bc5f98f370061
  $tcExpr_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2747577908562766668##
                   14614363197531079879##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tcExpr_1
                   0#
                   LamFunSyntax.$tcDefn_1) -}
324b68307fd9afbfbd35ccbb1f7fc270
  $tcExpr_1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tcExpr_2) -}
e62b7fd4807e7523496fe96928908a5a
  $tcExpr_2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Expr_"#) -}
d6590ac78d128a1d8f6d0f0c86b57946
  $tcProgram_ :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8286626253393763107##
                   17614537419722271697##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tcProgram_1
                   0#
                   LamFunSyntax.$tcDefn_1) -}
c666f1cd7c8abec46a2f04b929bac048
  $tcProgram_1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tcProgram_2) -}
35f682d02857cd42016d978a50f80895
  $tcProgram_2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Program_"#) -}
4b5a574c1ccb43d18fc983829495ca92
  $tcVersion :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4216075905882566346##
                   11972851779652840808##
                   LamFunSyntax.$trModule
                   LamFunSyntax.$tcVersion1
                   0#
                   GHC.Types.krep$*) -}
900fed9e8fc938889277a8b06532c148
  $tcVersion1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$tcVersion2) -}
b85a8f81415ee40fd16ccba2a24bcee2
  $tcVersion2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Version"#) -}
a9423fe43bb0b1e153628248da98fec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   LamFunSyntax.$trModule3
                   LamFunSyntax.$trModule1) -}
2234d096d28ae07fe70d277195964c0d
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$trModule2) -}
3a3f4ac9563ce394e6eb4ce2b9ca26aa
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("LamFunSyntax"#) -}
7ede660e2a273d87b50ffb6096bee7e9
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS LamFunSyntax.$trModule4) -}
ed23dd5ee03bfa6525fa02090e8fc292
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("LamFun-3.14.1-1NElG62CogO50XNaLIVWxW"#) -}
2242581a46528d9da58ce752528b158c
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> LamFunSyntax.Defn_ v a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: LamFunSyntax.Defn_ v a) ->
                 case w1 of wild {
                   LamFunSyntax.Val_ b1 b2
                   -> let {
                        f6 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w LamFunSyntax.$fShowDefn_4 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = LamFunSyntax.$fShowDefn__$cshowsPrec1
                            @ a
                            @ v
                            w
                            LamFunSyntax.$fShowDefn_4
                            b2
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             LamFunSyntax.$fShowDefn_3
                             (f6 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                LamFunSyntax.$fShowDefn_3
                                (f6
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))))) }
                   LamFunSyntax.Rec_ $d~ b1 b2
                   -> let {
                        f6 :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ a w LamFunSyntax.$fShowDefn_4 b1
                      } in
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = LamFunSyntax.$fShowDefn__$cshowsPrec1
                            @ a
                            @ v
                            w
                            LamFunSyntax.$fShowDefn_4
                            b2
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.CString.unpackAppendCString#
                             LamFunSyntax.$fShowDefn_2
                             (f6 (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                LamFunSyntax.$fShowDefn_2
                                (f6
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.showSpace1
                                      (g (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.$fShow(,)2
                                            x))))) } }) -}
8f11ad5d9dc6600f48b5495879bef02f
  $w$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> LamFunSyntax.Program_ v a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ @ a
                   @ v :: LamFunSyntax.Version
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: LamFunSyntax.Program_ v a) ->
                 case w1 of wild {
                   LamFunSyntax.Calculate_ b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = LamFunSyntax.$fShowDefn__$cshowsPrec1
                            @ a
                            @ v
                            w
                            LamFunSyntax.$fShowDefn_4
                            b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowProgram_3 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                LamFunSyntax.$fShowProgram_3
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }
                   LamFunSyntax.Define_ $d~ b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = LamFunSyntax.$w$cshowsPrec @ a @ v w 11# b1
                      } in
                      case GHC.Prim.>=# ww 11# of lwild {
                        DEFAULT
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowProgram_1 (g x)
                        1#
                        -> \ (x :: GHC.Base.String) ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.Base.++
                                @ GHC.Types.Char
                                LamFunSyntax.$fShowProgram_1
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) } }) -}
30fcd6637505d1a5ef24282cc7f41972
  $w$cshowsPrec2 ::
    LamFunSyntax.Version -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (w :: LamFunSyntax.Version)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   LamFunSyntax.LamCBN
                   -> GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowVersion11 w1
                   LamFunSyntax.LamCBV
                   -> GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowVersion9 w1
                   LamFunSyntax.LamNat
                   -> GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowVersion7 w1
                   LamFunSyntax.LamRec
                   -> GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowVersion5 w1
                   LamFunSyntax.LamMem
                   -> GHC.Base.++ @ GHC.Types.Char LamFunSyntax.$fShowVersion3 w1
                   LamFunSyntax.LamArray
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        LamFunSyntax.$fShowVersion1
                        w1 }) -}
8137985e9465995054d7109c5bdd77eb
  type family (<:) (a :: LamFunSyntax.Version)
                   (b :: LamFunSyntax.Version)
              :: GHC.Types.Bool
    where
        (<:) a a = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamCBN a = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamCBV a = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamNat 'LamFunSyntax.LamRec = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamNat 'LamFunSyntax.LamMem = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamNat 'LamFunSyntax.LamArray = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamRec 'LamFunSyntax.LamMem = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamRec 'LamFunSyntax.LamArray = 'GHC.Types.True
        (<:) 'LamFunSyntax.LamMem 'LamFunSyntax.LamArray = 'GHC.Types.True
        (<:) a b = 'GHC.Types.False
      axiom LamFunSyntax.D:R:<:
8137985e9465995054d7109c5bdd77eb
  axiom LamFunSyntax.D:R:<:::
      LamFunSyntax.<: a a = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamCBN a = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamCBV a = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamNat 'LamFunSyntax.LamRec
        = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamNat 'LamFunSyntax.LamMem
        = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamNat 'LamFunSyntax.LamArray
        = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamRec 'LamFunSyntax.LamMem
        = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamRec 'LamFunSyntax.LamArray
        = 'GHC.Types.True
      LamFunSyntax.<: 'LamFunSyntax.LamMem 'LamFunSyntax.LamArray
        = 'GHC.Types.True
      LamFunSyntax.<: a b = 'GHC.Types.False
      (incompatible indices: [8, 7, 6, 5, 4, 3, 2, 1, 0])
30fcd6637505d1a5ef24282cc7f41972
  axiom LamFunSyntax.D:R:DemoteVersion::
      Data.Singletons.Internal.Demote LamFunSyntax.Version
        = LamFunSyntax.Version
30fcd6637505d1a5ef24282cc7f41972
  axiom LamFunSyntax.D:R:SingVersion0::
      Data.Singletons.Internal.Sing = LamFunSyntax.R:SingVersion
2242581a46528d9da58ce752528b158c
  type role Defn_ nominal representational
  data Defn_ (a :: LamFunSyntax.Version) b where
    Val_ :: b -> (LamFunSyntax.Expr_ a b) -> Defn_ a b
    Rec_ :: (('LamFunSyntax.LamRec LamFunSyntax.<: a)
             Data.Type.Equality.~ 'GHC.Types.True) =>
            b -> (LamFunSyntax.Expr_ a b) -> Defn_ a b
2242581a46528d9da58ce752528b158c
  type role Expr_ nominal representational
  data Expr_ (a :: LamFunSyntax.Version) b where
    Variable_ :: b -> Expr_ a b
    Lambda_ :: b -> (LamFunSyntax.Expr_ a b) -> Expr_ a b
    App_ :: (LamFunSyntax.Expr_ a b) -> (LamFunSyntax.Expr_ a b)
            -> Expr_ a b
    Number_ :: (('LamFunSyntax.LamNat LamFunSyntax.<: a)
                Data.Type.Equality.~ 'GHC.Types.True) =>
               GHC.Integer.Type.Integer -> Expr_ a b
    Nil_ :: (('LamFunSyntax.LamNat LamFunSyntax.<: a)
             Data.Type.Equality.~ 'GHC.Types.True) =>
            Expr_ a b
    Cons_ :: (('LamFunSyntax.LamNat LamFunSyntax.<: a)
              Data.Type.Equality.~ 'GHC.Types.True) =>
             (LamFunSyntax.Expr_ a b) -> (LamFunSyntax.Expr_ a b) -> Expr_ a b
    Boolean_ :: (('LamFunSyntax.LamNat LamFunSyntax.<: a)
                 Data.Type.Equality.~ 'GHC.Types.True) =>
                GHC.Types.Bool -> Expr_ a b
    Case_ :: (('LamFunSyntax.LamRec LamFunSyntax.<: a)
              Data.Type.Equality.~ 'GHC.Types.True) =>
             (LamFunSyntax.Expr_ a b)
             -> [(GHC.Maybe.Maybe (LamFunSyntax.Expr_ a b),
                  LamFunSyntax.Expr_ a b)]
             -> Expr_ a b
    Let_ :: (('LamFunSyntax.LamRec LamFunSyntax.<: a)
             Data.Type.Equality.~ 'GHC.Types.True) =>
            (LamFunSyntax.Defn_ a b) -> (LamFunSyntax.Expr_ a b) -> Expr_ a b
    Assign_ :: (('LamFunSyntax.LamMem LamFunSyntax.<: a)
                Data.Type.Equality.~ 'GHC.Types.True) =>
               (LamFunSyntax.Expr_ a b) -> (LamFunSyntax.Expr_ a b) -> Expr_ a b
    While_ :: (('LamFunSyntax.LamMem LamFunSyntax.<: a)
               Data.Type.Equality.~ 'GHC.Types.True) =>
              (LamFunSyntax.Expr_ a b) -> (LamFunSyntax.Expr_ a b) -> Expr_ a b
    Contents_ :: (('LamFunSyntax.LamMem LamFunSyntax.<: a)
                  Data.Type.Equality.~ 'GHC.Types.True) =>
                 (LamFunSyntax.Expr_ a b) -> Expr_ a b
    Sequence_ :: (('LamFunSyntax.LamMem LamFunSyntax.<: a)
                  Data.Type.Equality.~ 'GHC.Types.True) =>
                 (LamFunSyntax.Expr_ a b) -> (LamFunSyntax.Expr_ a b) -> Expr_ a b
    StrLit_ :: (('LamFunSyntax.LamMem LamFunSyntax.<: a)
                Data.Type.Equality.~ 'GHC.Types.True) =>
               b -> Expr_ a b
db41f0b953844ec62f0f76ec663f8488
  type LamArraySym0 = 'LamFunSyntax.LamArray :: LamFunSyntax.Version
a82c796baefbf100b8c2eb9113be455d
  type LamCBNSym0 = 'LamFunSyntax.LamCBN :: LamFunSyntax.Version
69474b7f3c84e60930e49b8348a014ae
  type LamCBVSym0 = 'LamFunSyntax.LamCBV :: LamFunSyntax.Version
15697e3785df3b462b3cdba230df64b6
  type LamMemSym0 = 'LamFunSyntax.LamMem :: LamFunSyntax.Version
a04c14f468cec499047d8f1113b567f5
  type LamNatSym0 = 'LamFunSyntax.LamNat :: LamFunSyntax.Version
a53c69c105b469bef04134518bb16ae0
  type LamRecSym0 = 'LamFunSyntax.LamRec :: LamFunSyntax.Version
8f11ad5d9dc6600f48b5495879bef02f
  type role Program_ nominal representational
  data Program_ (a :: LamFunSyntax.Version) b where
    Calculate_ :: (LamFunSyntax.Expr_ a b) -> Program_ a b
    Define_ :: (('LamFunSyntax.LamNat LamFunSyntax.<: a)
                Data.Type.Equality.~ 'GHC.Types.True) =>
               (LamFunSyntax.Defn_ a b) -> Program_ a b
30fcd6637505d1a5ef24282cc7f41972
  data instance Data.Singletons.Internal.Sing a where
    SLamCBN :: Data.Singletons.Internal.Sing 'LamFunSyntax.LamCBN
    SLamCBV :: Data.Singletons.Internal.Sing 'LamFunSyntax.LamCBV
    SLamNat :: Data.Singletons.Internal.Sing 'LamFunSyntax.LamNat
    SLamRec :: Data.Singletons.Internal.Sing 'LamFunSyntax.LamRec
    SLamMem :: Data.Singletons.Internal.Sing 'LamFunSyntax.LamMem
    SLamArray :: Data.Singletons.Internal.Sing 'LamFunSyntax.LamArray
7241a26c7307527e0ac015f03d26c954
  type SVersion =
    Data.Singletons.Internal.Sing :: LamFunSyntax.Version -> *
30fcd6637505d1a5ef24282cc7f41972
  data Version
    = LamCBN | LamCBV | LamNat | LamRec | LamMem | LamArray
995db1631fe4479f80310cd6fc04fa4e
  unsafeMkAssign_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m10,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (a1 :: LamFunSyntax.Expr_ v a)
                   (b :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT -> LamFunSyntax.unsafeMkAssign_1 @ a @ v
                   LamFunSyntax.SLamMem co
                   -> LamFunSyntax.Assign_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                <'LamFunSyntax.LamMem>_N) ; (<'LamFunSyntax.LamMem>_N
                                                                                             LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                        b
                   LamFunSyntax.SLamArray co
                   -> LamFunSyntax.Assign_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[8]) ; (<'LamFunSyntax.LamMem>_N
                                                                                       LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                        b }) -}
5ea97d00881b25eb1bac3e68d1371a6d
  unsafeMkAssign_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
b20e129295fd38da17d4c094a634706b
  unsafeMkBoolean_ ::
    Data.Singletons.Internal.SingI v =>
    GHC.Types.Bool -> LamFunSyntax.Expr_ v a
  {- Arity: 2, Strictness: <S,1*U><L,U>m7,
     Unfolding: InlineRule (2, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: GHC.Types.Bool) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Boolean_
                         @ 'LamFunSyntax.LamNat
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamNat>_N)) <'GHC.Types.True>_N)
                         eta)
                        `cast`
                      (Nth:3
                           (<GHC.Types.Bool>_R
                            ->_R (LamFunSyntax.Expr_
                                    (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkBoolean_2 @ a @ v
                   LamFunSyntax.SLamCBV co
                   -> LamFunSyntax.unsafeMkBoolean_1 @ a @ v }) -}
04e3f1fb04e1d96ff7c728e9b3a1b1a1
  unsafeMkBoolean_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
431dbe8d82d7e1c1374b83b9bc643d47
  unsafeMkBoolean_2 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
fa10a087001f645c93126e03259a0232
  unsafeMkCase_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Expr_ v a
    -> [(GHC.Maybe.Maybe (LamFunSyntax.Expr_ v a),
         LamFunSyntax.Expr_ v a)]
    -> LamFunSyntax.Expr_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m8,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: LamFunSyntax.Expr_ v a)
                   (eta1 :: [(GHC.Maybe.Maybe (LamFunSyntax.Expr_ v a),
                              LamFunSyntax.Expr_ v a)]) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Case_
                         @ 'LamFunSyntax.LamRec
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamRec>_N)) <'GHC.Types.True>_N)
                         eta
                           `cast`
                         (Nth:2
                              ((LamFunSyntax.Expr_
                                  (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                               ->_R ([((,)
                                         (GHC.Maybe.Maybe
                                            (LamFunSyntax.Expr_
                                               (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R)_R
                                         (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamRec)
                                            <a>_R)_R)_R])_R
                               ->_R (LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R))
                         eta1
                           `cast`
                         (Nth:2
                              (Nth:3
                                   ((LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                                    ->_R ([((,)
                                              (GHC.Maybe.Maybe
                                                 (LamFunSyntax.Expr_
                                                    (UnsafeCo nominal v 'LamFunSyntax.LamRec)
                                                    <a>_R)_R)_R
                                              (LamFunSyntax.Expr_
                                                 (UnsafeCo nominal v 'LamFunSyntax.LamRec)
                                                 <a>_R)_R)_R])_R
                                    ->_R (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R))))
                        `cast`
                      (Nth:3
                           (Nth:3
                                ((LamFunSyntax.Expr_
                                    (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R
                                 ->_R ([((,)
                                           (GHC.Maybe.Maybe
                                              (LamFunSyntax.Expr_
                                                 (UnsafeCo nominal 'LamFunSyntax.LamRec v)
                                                 <a>_R)_R)_R
                                           (LamFunSyntax.Expr_
                                              (UnsafeCo nominal 'LamFunSyntax.LamRec v)
                                              <a>_R)_R)_R])_R
                                 ->_R (LamFunSyntax.Expr_
                                         (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R)))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkCase_3 @ a @ v
                   LamFunSyntax.SLamCBV co -> LamFunSyntax.unsafeMkCase_2 @ a @ v
                   LamFunSyntax.SLamNat co
                   -> LamFunSyntax.unsafeMkCase_1 @ a @ v }) -}
c780b0d9df5f387c80fc757110e09152
  unsafeMkCase_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
b1dae6af9e51222f09a2443536782e14
  unsafeMkCase_2 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
b335027fdb7a01c402f56894917d92d5
  unsafeMkCase_3 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
b39fc687b79142fa1c67c2da0d6180ea
  unsafeMkCons_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m6,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: LamFunSyntax.Expr_ v a)
                   (eta1 :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Cons_
                         @ 'LamFunSyntax.LamNat
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamNat>_N)) <'GHC.Types.True>_N)
                         eta
                           `cast`
                         (Nth:2
                              ((LamFunSyntax.Expr_
                                  (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R
                               ->_R (LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R
                               ->_R (LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R))
                         eta1
                           `cast`
                         (Nth:2
                              (Nth:3
                                   ((LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R
                                    ->_R (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R
                                    ->_R (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R))))
                        `cast`
                      (Nth:3
                           (Nth:3
                                ((LamFunSyntax.Expr_
                                    (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R
                                 ->_R (LamFunSyntax.Expr_
                                         (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R
                                 ->_R (LamFunSyntax.Expr_
                                         (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R)))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkCons_2 @ a @ v
                   LamFunSyntax.SLamCBV co
                   -> LamFunSyntax.unsafeMkCons_1 @ a @ v }) -}
bbbb4f4362639f69c350251610bd0f93
  unsafeMkCons_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
88c69289a197aaa67196993368477d3f
  unsafeMkCons_2 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
3c6b31440b0a7358e4f784511faf04d6
  unsafeMkContents_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 2, Strictness: <S,1*U><L,U>m12,
     Unfolding: InlineRule (2, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (a1 :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT -> LamFunSyntax.unsafeMkContents_1 @ a @ v
                   LamFunSyntax.SLamMem co
                   -> LamFunSyntax.Contents_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                <'LamFunSyntax.LamMem>_N) ; (<'LamFunSyntax.LamMem>_N
                                                                                             LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                   LamFunSyntax.SLamArray co
                   -> LamFunSyntax.Contents_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[8]) ; (<'LamFunSyntax.LamMem>_N
                                                                                       LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1 }) -}
64b7d6b2dba8df6da42628ddcccdc4b5
  unsafeMkContents_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
f82870ef2adfd61f68f44092aeec1477
  unsafeMkDefine_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Defn_ v a -> LamFunSyntax.Program_ v a
  {- Arity: 2, Strictness: <S,1*U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: LamFunSyntax.Defn_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Define_
                         @ 'LamFunSyntax.LamNat
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamNat>_N)) <'GHC.Types.True>_N)
                         eta
                           `cast`
                         (Nth:2
                              ((LamFunSyntax.Defn_
                                  (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R
                               ->_R (LamFunSyntax.Program_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamNat) <a>_R)_R)))
                        `cast`
                      (Nth:3
                           ((LamFunSyntax.Defn_
                               (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R
                            ->_R (LamFunSyntax.Program_
                                    (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkDefine_2 @ a @ v
                   LamFunSyntax.SLamCBV co
                   -> LamFunSyntax.unsafeMkDefine_1 @ a @ v }) -}
ddb7a18d9d2b8efeef77c0f26fb68377
  unsafeMkDefine_1 :: LamFunSyntax.Program_ v a
  {- Strictness: x -}
45b8538955d040c873727a306487e6b1
  unsafeMkDefine_2 :: LamFunSyntax.Program_ v a
  {- Strictness: x -}
9baa1f65825bd1ef9dff63d288bd6a49
  unsafeMkLet_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Defn_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m9,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: LamFunSyntax.Defn_ v a)
                   (eta1 :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Let_
                         @ 'LamFunSyntax.LamRec
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamRec>_N)) <'GHC.Types.True>_N)
                         eta
                           `cast`
                         (Nth:2
                              ((LamFunSyntax.Defn_
                                  (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                               ->_R (LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                               ->_R (LamFunSyntax.Expr_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R))
                         eta1
                           `cast`
                         (Nth:2
                              (Nth:3
                                   ((LamFunSyntax.Defn_
                                       (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                                    ->_R (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                                    ->_R (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R))))
                        `cast`
                      (Nth:3
                           (Nth:3
                                ((LamFunSyntax.Defn_
                                    (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R
                                 ->_R (LamFunSyntax.Expr_
                                         (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R
                                 ->_R (LamFunSyntax.Expr_
                                         (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R)))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkLet_3 @ a @ v
                   LamFunSyntax.SLamCBV co -> LamFunSyntax.unsafeMkLet_2 @ a @ v
                   LamFunSyntax.SLamNat co -> LamFunSyntax.unsafeMkLet_1 @ a @ v }) -}
fb631f18e68c5a730fc75b23fedc1e6b
  unsafeMkLet_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
5bfc510b51f666d84df92b3860b96978
  unsafeMkLet_2 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
b96a5a583896102d517e50a6d8850639
  unsafeMkLet_3 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
a5894306a5bfb2e9361e09f77439d883
  unsafeMkNil_ ::
    Data.Singletons.Internal.SingI v => LamFunSyntax.Expr_ v a
  {- Arity: 1, Strictness: <S,1*U>m5,
     Unfolding: InlineRule (1, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.unsafeMkNil_3 @ a)
                        `cast`
                      (LamFunSyntax.Expr_
                         (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkNil_2 @ a @ v
                   LamFunSyntax.SLamCBV co -> LamFunSyntax.unsafeMkNil_1 @ a @ v }) -}
f4c7c18c008442df64ffdf4aeb78d4d5
  unsafeMkNil_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
02870c8c5fc65e91feeabe57a6f74aa3
  unsafeMkNil_2 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
fda220410de1931d01c591d24fb37c06
  unsafeMkNil_3 :: LamFunSyntax.Expr_ 'LamFunSyntax.LamNat a
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (\ @ a ->
                 LamFunSyntax.Nil_
                   @ 'LamFunSyntax.LamNat
                   @ a
                   LamFunSyntax.unsafeMkNil_4
                     `cast`
                   (Sym (Data.Type.Equality.N:~[0]
                             <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                           <'LamFunSyntax.LamNat>_N)) <'GHC.Types.True>_N)) -}
3edbd60f15d821b1201b748b4a8a09b4
  unsafeMkNil_4 :: 'GHC.Types.True GHC.Types.~~ 'GHC.Types.True
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Eq#
                   @ GHC.Types.Bool
                   @ GHC.Types.Bool
                   @ 'GHC.Types.True
                   @ 'GHC.Types.True
                   @~ <'GHC.Types.True>_N) -}
754ebee262867a7f8e536163178040fb
  unsafeMkNumber_ ::
    Data.Singletons.Internal.SingI v =>
    GHC.Integer.Type.Integer -> LamFunSyntax.Expr_ v a
  {- Arity: 2, Strictness: <S,1*U><L,U>m4,
     Unfolding: InlineRule (2, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: GHC.Integer.Type.Integer) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Number_
                         @ 'LamFunSyntax.LamNat
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamNat>_N)) <'GHC.Types.True>_N)
                         eta)
                        `cast`
                      (Nth:3
                           (<GHC.Integer.Type.Integer>_R
                            ->_R (LamFunSyntax.Expr_
                                    (UnsafeCo nominal 'LamFunSyntax.LamNat v) <a>_R)_R))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkNumber_2 @ a @ v
                   LamFunSyntax.SLamCBV co
                   -> LamFunSyntax.unsafeMkNumber_1 @ a @ v }) -}
981910fe1dc491a0061b14502af160c0
  unsafeMkNumber_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
fd585bb734f9c3c12b9c901e81f34f20
  unsafeMkNumber_2 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
90abe387d482aa8ab3bb2e3ffc05cf62
  unsafeMkRec_ ::
    Data.Singletons.Internal.SingI v =>
    a -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Defn_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m2,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (eta :: a)
                   (eta1 :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT
                   -> (LamFunSyntax.Rec_
                         @ 'LamFunSyntax.LamRec
                         @ a
                         (GHC.Types.Eq#
                            @ GHC.Types.Bool
                            @ GHC.Types.Bool
                            @ 'GHC.Types.True
                            @ 'GHC.Types.True
                            @~ <'GHC.Types.True>_N)
                           `cast`
                         (Sym (Data.Type.Equality.N:~[0]
                                   <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                 <'LamFunSyntax.LamRec>_N)) <'GHC.Types.True>_N)
                         eta
                         eta1
                           `cast`
                         (Nth:2
                              (Nth:3
                                   (<a>_R
                                    ->_R (LamFunSyntax.Expr_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R
                                    ->_R (LamFunSyntax.Defn_
                                            (UnsafeCo nominal v 'LamFunSyntax.LamRec) <a>_R)_R))))
                        `cast`
                      (Nth:3
                           (Nth:3
                                (<a>_R
                                 ->_R (LamFunSyntax.Expr_
                                         (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R
                                 ->_R (LamFunSyntax.Defn_
                                         (UnsafeCo nominal 'LamFunSyntax.LamRec v) <a>_R)_R)))
                   LamFunSyntax.SLamCBN co -> LamFunSyntax.unsafeMkRec_3 @ a @ v
                   LamFunSyntax.SLamCBV co -> LamFunSyntax.unsafeMkRec_2 @ a @ v
                   LamFunSyntax.SLamNat co -> LamFunSyntax.unsafeMkRec_1 @ a @ v }) -}
5bc224b37ca0660d37f50f36d0b3233d
  unsafeMkRec_1 :: LamFunSyntax.Defn_ v a
  {- Strictness: x -}
9deed7c7376c5ce84f0518162cf7c831
  unsafeMkRec_2 :: LamFunSyntax.Defn_ v a
  {- Strictness: x -}
1c68b69cb53ce0b44ebc1eb4bba9b512
  unsafeMkRec_3 :: LamFunSyntax.Defn_ v a
  {- Strictness: x -}
4e42ec4fcd77eb735e00e34f16e31e50
  unsafeMkSequence_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m13,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (a1 :: LamFunSyntax.Expr_ v a)
                   (b :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT -> LamFunSyntax.unsafeMkSequence_1 @ a @ v
                   LamFunSyntax.SLamMem co
                   -> LamFunSyntax.Sequence_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                <'LamFunSyntax.LamMem>_N) ; (<'LamFunSyntax.LamMem>_N
                                                                                             LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                        b
                   LamFunSyntax.SLamArray co
                   -> LamFunSyntax.Sequence_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[8]) ; (<'LamFunSyntax.LamMem>_N
                                                                                       LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                        b }) -}
e866b33af2b22cb172d1ce905647fc9d
  unsafeMkSequence_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
f333fc2982715cf3276c924661f100af
  unsafeMkStrLit_ ::
    Data.Singletons.Internal.SingI v => a -> LamFunSyntax.Expr_ v a
  {- Arity: 2, Strictness: <S,1*U><L,U>m14,
     Unfolding: InlineRule (2, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (a1 :: a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT -> LamFunSyntax.unsafeMkStrLit_1 @ a @ v
                   LamFunSyntax.SLamMem co
                   -> LamFunSyntax.StrLit_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                <'LamFunSyntax.LamMem>_N) ; (<'LamFunSyntax.LamMem>_N
                                                                                             LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                   LamFunSyntax.SLamArray co
                   -> LamFunSyntax.StrLit_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[8]) ; (<'LamFunSyntax.LamMem>_N
                                                                                       LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1 }) -}
f84b8a02ad4605a12a1cb9a73d83745e
  unsafeMkStrLit_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
2cde02854edbcee3f7b542ebac75329a
  unsafeMkWhile_ ::
    Data.Singletons.Internal.SingI v =>
    LamFunSyntax.Expr_ v a
    -> LamFunSyntax.Expr_ v a -> LamFunSyntax.Expr_ v a
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>m11,
     Unfolding: InlineRule (3, True, False)
                (\ @ v :: LamFunSyntax.Version
                   @ a
                   ($dSingI :: Data.Singletons.Internal.SingI v)
                   (a1 :: LamFunSyntax.Expr_ v a)
                   (b :: LamFunSyntax.Expr_ v a) ->
                 case $dSingI
                        `cast`
                      ((Data.Singletons.Internal.N:SingI[0] <LamFunSyntax.Version>_N ; LamFunSyntax.D:R:SingVersion0[0]) <v>_N) of wild {
                   DEFAULT -> LamFunSyntax.unsafeMkWhile_1 @ a @ v
                   LamFunSyntax.SLamMem co
                   -> LamFunSyntax.While_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[0]
                                                                <'LamFunSyntax.LamMem>_N) ; (<'LamFunSyntax.LamMem>_N
                                                                                             LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                        b
                   LamFunSyntax.SLamArray co
                   -> LamFunSyntax.While_
                        @ v
                        @ a
                        (GHC.Types.Eq#
                           @ GHC.Types.Bool
                           @ GHC.Types.Bool
                           @ 'GHC.Types.True
                           @ 'GHC.Types.True
                           @~ <'GHC.Types.True>_N)
                          `cast`
                        (Sym (Data.Type.Equality.N:~[0]
                                  <GHC.Types.Bool>_N) (Sym (LamFunSyntax.D:R:<:[8]) ; (<'LamFunSyntax.LamMem>_N
                                                                                       LamFunSyntax.<: Sym co)_N) <'GHC.Types.True>_N)
                        a1
                        b }) -}
b5e62307c07e8514b0b28a236353aa6e
  unsafeMkWhile_1 :: LamFunSyntax.Expr_ v a
  {- Strictness: x -}
instance GHC.Classes.Eq [LamFunSyntax.Defn_]
  = LamFunSyntax.$fEqDefn_
instance GHC.Classes.Eq [LamFunSyntax.Expr_]
  = LamFunSyntax.$fEqExpr_
instance GHC.Classes.Eq [LamFunSyntax.Program_]
  = LamFunSyntax.$fEqProgram_
instance GHC.Classes.Eq [LamFunSyntax.Version]
  = LamFunSyntax.$fEqVersion
instance GHC.Base.Functor [LamFunSyntax.Defn_]
  = LamFunSyntax.$fFunctorDefn_
instance GHC.Base.Functor [LamFunSyntax.Expr_]
  = LamFunSyntax.$fFunctorExpr_
instance GHC.Base.Functor [LamFunSyntax.Program_]
  = LamFunSyntax.$fFunctorProgram_
instance GHC.Classes.Ord [LamFunSyntax.Defn_]
  = LamFunSyntax.$fOrdDefn_
instance GHC.Classes.Ord [LamFunSyntax.Expr_]
  = LamFunSyntax.$fOrdExpr_
instance GHC.Classes.Ord [LamFunSyntax.Program_]
  = LamFunSyntax.$fOrdProgram_
instance GHC.Show.Show [LamFunSyntax.Defn_]
  = LamFunSyntax.$fShowDefn_
instance GHC.Show.Show [LamFunSyntax.Expr_]
  = LamFunSyntax.$fShowExpr_
instance GHC.Show.Show [LamFunSyntax.Program_]
  = LamFunSyntax.$fShowProgram_
instance GHC.Show.Show [LamFunSyntax.Version]
  = LamFunSyntax.$fShowVersion
instance Data.Singletons.Internal.SingI [LamFunSyntax.Version,
                                         LamFunSyntax.LamArray]
  = LamFunSyntax.$fSingIVersionLamArray
instance Data.Singletons.Internal.SingI [LamFunSyntax.Version,
                                         LamFunSyntax.LamCBN]
  = LamFunSyntax.$fSingIVersionLamCBN
instance Data.Singletons.Internal.SingI [LamFunSyntax.Version,
                                         LamFunSyntax.LamCBV]
  = LamFunSyntax.$fSingIVersionLamCBV
instance Data.Singletons.Internal.SingI [LamFunSyntax.Version,
                                         LamFunSyntax.LamMem]
  = LamFunSyntax.$fSingIVersionLamMem
instance Data.Singletons.Internal.SingI [LamFunSyntax.Version,
                                         LamFunSyntax.LamNat]
  = LamFunSyntax.$fSingIVersionLamNat
instance Data.Singletons.Internal.SingI [LamFunSyntax.Version,
                                         LamFunSyntax.LamRec]
  = LamFunSyntax.$fSingIVersionLamRec
instance Data.Singletons.Internal.SingKind [LamFunSyntax.Version]
  = LamFunSyntax.$fSingKindVersion
family instance Data.Singletons.Internal.Demote [LamFunSyntax.Version]
  = LamFunSyntax.D:R:DemoteVersion
family instance Data.Singletons.Internal.Sing [LamFunSyntax.Version]
  = LamFunSyntax.D:R:SingVersion0
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

